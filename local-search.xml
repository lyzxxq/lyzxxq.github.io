<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库概论五：事务处理、并发控制与故障恢复技术</title>
    <link href="/2022/11/19/database_note_5/"/>
    <url>/2022/11/19/database_note_5/</url>
    
    <content type="html"><![CDATA[<h2 id="一、事务处理"><a href="#一、事务处理" class="headerlink" title="一、事务处理"></a>一、事务处理</h2><h3 id="（一）事务"><a href="#（一）事务" class="headerlink" title="（一）事务"></a>（一）事务</h3><h4 id="1-事务（transaction）"><a href="#1-事务（transaction）" class="headerlink" title="1. 事务（transaction）"></a>1. 事务（transaction）</h4><ul><li>由某个用户所执行的一个不能被打断的对数据库的操作序列被称为<strong>事务</strong><ul><li><strong>事务</strong>是应用程序访问数据库的基本逻辑工作单位</li><li><strong>事务</strong>通常由一组对数据库的访问操作组成，在执行过程中按照预定的次序顺序执行</li><li>一个<strong>事务</strong>的执行过程是串行的，它将数据库从一个旧的一致性状态转换到一个新的一致性状态。在<strong>事务</strong>的执行过程中，数据库中的数据可能有不一致的现象，但在‘事务’执行结束时，系统将保证数据库中数据的一致性</li></ul></li></ul><h4 id="2-事务的性质"><a href="#2-事务的性质" class="headerlink" title="2. 事务的性质"></a>2. 事务的性质</h4><ul><li><p>事务具有四个特性，简称为事务的<strong>ACID</strong>特性，也被称为事务的执行过程必须满足的四条准则</p><ul><li><p>原子性（<strong>A</strong>tomicity）</p><ul><li><p>在一个事务中，所有的数据库访问操作构成一个不可分割的操作序列，这些操作要么全部执行结束，要么一个都不要执行。(例：银行转账）</p></li><li><p>数据库管理系统会自动维护用户事务执行的原子性</p><ul><li><p>事务管理子系统</p></li><li><p>事务日志</p></li></ul></li></ul></li><li><p>一致性（<strong>C</strong>onsistency）</p><ul><li><p>一个事务的成功执行总是将数据库从一个一致的状态转换到另一个一致的状态</p><ul><li>数据库的<strong>状态</strong>：指数据库中所有数据对象的当前取值情况</li></ul></li><li><p>数据库的一致的状态可以理解为数据库中所有数据的正确性，它要求数据库中的数据必须满足：</p><ul><li><p>在数据库中显式定义的各种完整性约束</p></li><li><p>用户心目中的隐式数据约束</p></li></ul></li><li><p>事务执行的<strong>一致性</strong>原则基于这样一个假设：</p><ul><li>在一个事务开始执行之前数据库处于一个一致的状态，如果没有<strong>其它事务的干扰和系统故障</strong>，那么当该事务执行结束时数据库仍然处于一致的状态</li></ul></li><li><p>事务的<strong>一致性</strong>特性由两方面完成</p><ul><li>DBMS中的<strong>数据完整性保护</strong>子系统</li><li>编写事务的应用程序员</li></ul></li></ul></li><li><p>隔离性（<strong>I</strong>solation）</p><ul><li>一个事务的执行与并发执行的其它事务之间是相互独立的，互不干扰，这被称为事务执行的<strong>隔离性</strong></li><li>事务执行的<strong>隔离性</strong>要求：<ul><li>多个事务并发执行的最终结果，应该与它们的某种串行执行的最终结果相等，这被称为并发事务的可串行化</li></ul></li><li>事务执行的<strong>隔离性</strong>是由<strong>DBMS</strong>的并发控制子系统来实现的。<ul><li>在数据库系统中，当多个事务并发执行时，每个事务都可以看成只有自己在执行，只有当它与其它事务发生封锁冲突时，才会感觉到其它事务的存在</li></ul></li></ul></li><li><p>持久性（<strong>D</strong>urability）</p><ul><li>一个事务一旦完成其全部操作后，它对数据库的所有更新应永久地反映在数据库中，即使以后系统发生故障也应该能够通过故障恢复来保留这个事务的执行结果</li><li>事务的<strong>持久性</strong>是由<strong>DBMS</strong>的恢复管理子系统实现的</li></ul></li></ul></li><li><p>数据库管理系统通过其<strong>事务管理</strong>子系统（含<strong>并发控制</strong>子系统）、<strong>恢复管理</strong>子系统、<strong>数据完整性保护</strong>子系统来实现事务的原子性(A)、一致性(C)、隔离性(I)和持久性(D)</p></li></ul><h3 id="（二）事务活动"><a href="#（二）事务活动" class="headerlink" title="（二）事务活动"></a>（二）事务活动</h3><p><img src="/img/posts/DB-5-1.jpg" alt="这是图片" title="事务活动过程图"></p><ul><li>为了精确地描述一个事务的工作过程，我们建立了一个抽象的事务模型，以表示事务的状态变迁情况</li></ul><p><img src="/img/posts/DB-5-2.jpg" alt="这是图片" title="事务状态变迁图"></p><h4 id="1-活动状态"><a href="#1-活动状态" class="headerlink" title="1. 活动状态"></a>1. 活动状态</h4><ul><li><p>事务在开始执行后，立即进入<strong>活动</strong>状态。在<strong>活动</strong>状态中，事务将执行对数据库的访问操作</p></li><li><p>在<strong>DBMS</strong>的事务管理子系统看来，用户事务对数据库的访问操作就是对数据库中数据的读 &#x2F; 写操作</p></li><li><p><strong>读</strong>操作</p><ul><li>将数据读入用户事务的私有工作区间</li><li>如果该数据当前不在<strong>DBMS</strong>的系统缓冲区中，那么<strong>DBMS</strong>首先将该数据从磁盘读入系统缓冲区，然后再将其拷贝到用户事务的私有工作区</li></ul></li><li><p><strong>写</strong>操作</p><ul><li>将修改后的数据<strong>写入</strong>数据库</li><li>这里的<strong>写</strong>操作并不是立即将数据永久性地写入磁盘，很可能暂时存放在<strong>DBMS</strong>的系统缓冲区中</li></ul></li></ul><h4 id="2-预提交状态"><a href="#2-预提交状态" class="headerlink" title="2. 预提交状态"></a>2. 预提交状态</h4><ul><li>当事务的最后一条访问语句执行结束之后，事务进入<strong>预提交</strong>状态。此时事务对于数据库的访问操作虽然已经执行结束，但其对于数据的修改结果可能还在内存的系统缓冲区中，必须将其真正写入数据库的磁盘</li><li>事务在<strong>预提交</strong>阶段，必须确保将当前事务的所有修改操作的执行结果被真正写入到数据库的磁盘中去</li><li>在所有<strong>写</strong>磁盘操作执行结束后，事务就进入<strong>提交</strong>状态</li><li>在<strong>预提交</strong>阶段，虽然事务本身的操作命令已经执行结束，但是在写磁盘的过程中仍然会发生系统故障，从而导致当前事务的执行失败<ul><li>在<strong>预提交</strong>失败后，当前事务也将被放弃(abort)，事务转而进入<strong>失败</strong>状态</li></ul></li></ul><h4 id="3-失败状态"><a href="#3-失败状态" class="headerlink" title="3. 失败状态"></a>3. 失败状态</h4><ul><li>处于<strong>活动</strong>状态的事务在顺利到达并执行完最后一条语句之前就中止执行，或者在<strong>预提交</strong>状态下因发生系统故障而中止执行时，我们称事务进入<strong>失败</strong>状态<ul><li><p>事务从<strong>活动</strong>状态转变为<strong>失败</strong>状态的原因</p><ul><li><p>应用程序（或用户）主动放弃当前事务</p></li><li><p>因并发控制的原因而被放弃的事务，如：</p><ul><li>封锁申请的超时等待</li><li>死锁</li></ul></li><li><p>发生系统故障</p></li></ul></li><li><p>事务从<strong>预提交</strong>状态转变为<strong>失败</strong>状态的原因</p><ul><li>发生系统故障</li></ul></li></ul></li></ul><h4 id="4-异常中止状态"><a href="#4-异常中止状态" class="headerlink" title="4. 异常中止状态"></a>4. 异常中止状态</h4><ul><li>处于<strong>失败</strong>状态的事务，很可能已对磁盘中的数据进行了一部分修改。为了保证事务的原子性，系统应该撤消 (undo 操作) 该事务对数据库已作的修改。在撤消操作完成以后，事务将被打上一个放弃的标志 (aborted)，转而进入<strong>异常中止</strong>状态<ul><li><p>回退 (rollback)</p><ul><li><p>对事务的撤消操作也称为事务的<strong>回退</strong>或<strong>回滚</strong></p></li><li><p>事务的<strong>回退</strong>由<strong>DBMS</strong>的<strong>恢复子系统</strong>实现</p></li></ul></li><li><p>在事务进入<strong>异常中止</strong>状态后，系统有两种选择：</p><ul><li>作为一个新的事务，重新启动</li><li>取消事务</li></ul></li></ul></li></ul><h4 id="5-提交状态"><a href="#5-提交状态" class="headerlink" title="5. 提交状态"></a>5. 提交状态</h4><ul><li><p>事务进入<strong>预提交</strong>状态后，<strong>并发控制子系统</strong>将检查该事务与并发执行的其它事务之间是否发生干扰现象</p></li><li><p>在检查通过以后，系统执行提交 (commit) 操作，把对数据库的修改全部写到磁盘上，并通知系统，事务已成功地结束</p></li><li><p>不论是<strong>提交</strong>状态，还是<strong>异常中止</strong>状态，都意味着一个事务的执行结束</p></li></ul><h3 id="（三）有关事务的语句"><a href="#（三）有关事务的语句" class="headerlink" title="（三）有关事务的语句"></a>（三）有关事务的语句</h3><h4 id="1-事务的开始-begin-transaction"><a href="#1-事务的开始-begin-transaction" class="headerlink" title="1. 事务的开始(begin transaction)"></a>1. 事务的开始(begin transaction)</h4><ul><li><p>现有的关系数据库管理系统并没有提供一个用于定义从什么时候开始一个事务的控制语句，事务的启动是隐式的</p></li><li><p>可以通过三种方式来启动一个新的事务：</p><ul><li><p>数据定义命令 (DDL)</p><ul><li>每一条数据定义命令都将被作为一个单独的事务来执行</li><li>在此之前的用户事务将被自动提交</li></ul></li><li><p>将系统设为自动提交方式（打开自动提交标志）</p><ul><li>每一条数据库访问命令都将被作为一个单独的事务来执行，并根据执行结果自动提交或回退</li></ul></li><li><p>数据操纵命令 (DML)</p><ul><li>在当前用户的前一个事务执行结束之后，在用户提交的下一条数据库访问操作之前，数据库管理系统将自动启动一个新的事务</li></ul></li></ul></li></ul><h4 id="2-事务的结束"><a href="#2-事务的结束" class="headerlink" title="2. 事务的结束"></a>2. 事务的结束</h4><h5 id="（1）正常结束：提交事务-commit-transaction"><a href="#（1）正常结束：提交事务-commit-transaction" class="headerlink" title="（1）正常结束：提交事务 (commit transaction)"></a>（1）正常结束：提交事务 (commit transaction)</h5><ul><li>提交当前事务，事务在执行过程中对于数据库的所有修改操作都将永久地反应到数据库中，并且不可被取消</li><li>事务的提交操作也可能失败，其原因包括：<ul><li>发生系统故障</li><li>在提交阶段执行的数据完整性检查</li></ul></li><li>在事务提交失败后，用户可以通过回退 (Rollback) 操作来取消当前事务<ul><li>由系统自动提交的事务，如果提交失败，系统将自动执行事务的回退操作</li></ul></li></ul><h5 id="（2）非正常结束：回退事务-rollback-transaction"><a href="#（2）非正常结束：回退事务-rollback-transaction" class="headerlink" title="（2）非正常结束：回退事务 (rollback transaction)"></a>（2）非正常结束：回退事务 <strong>(rollback transaction)</strong></h5><ul><li>取消在该事务执行过程中的所有操作，回滚该事务至事务的起点，以便重新执行或放弃（ abort ）该事务</li><li>检查点 (save point) <ul><li>在事务的执行过程中，系统可以为该事务设置若干个检查点</li><li>用户事务可以使用 Rollback 命令将当前事务回退到前面的某个检查点 sp ，放弃<strong>在检查点 sp 之后，回退操作之前</strong>执行的对数据库的所有访问操作，并继续执行当前事务</li><li>不带检查点的回退操作将结束并放弃整个事务</li></ul></li></ul><h4 id="3-与事务有关的控制命令-DCL"><a href="#3-与事务有关的控制命令-DCL" class="headerlink" title="3. 与事务有关的控制命令(DCL)"></a>3. 与事务有关的控制命令(DCL)</h4><ul><li><p>设置事务的自动提交命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> AUTO <span class="hljs-keyword">COMMIT</span> <span class="hljs-keyword">ON</span>｜OFF<br></code></pre></td></tr></table></figure></li><li><p>设置事务的类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> TRANSACTION READONLY<span class="hljs-operator">|</span>READWRITE<br></code></pre></td></tr></table></figure><ul><li><p>定义在这之后启动的所有事务在执行过程中对数据库的访问方式</p><ul><li><p><strong>READONLY</strong>：只读型事务</p><ul><li>在事务的运行过程中只能执行对数据库的<strong>读</strong>操作，而不能执行<strong>更新</strong>类型的操作</li><li>直到定义新的事务类型</li></ul></li><li><p><strong>READWRITE</strong>：读 &#x2F; 写型事务</p><ul><li>在事务的运行过程中可以执行对数据库的<strong>读 &#x2F; 写</strong>操作</li><li>这是事务的缺省类型定义</li></ul></li></ul></li></ul></li><li><p>设置事务的隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL<br>READUNCOMMITTED<span class="hljs-operator">|</span>READCOMMITTED<span class="hljs-operator">|</span>READREPEATABLE<span class="hljs-operator">|</span>SERIALIZABLE<br></code></pre></td></tr></table></figure><ul><li><p>定义当前用户的事务与其它并发执行事务之间的隔离级别</p></li><li><p>事务的隔离级别与所采用的封锁策略紧密相关。选择不同的隔离级别，系统所采用的封锁策略则不同</p></li><li><p>有四种不同的隔离级别可供选择</p><ul><li><p><strong>READUNCOMMITTED</strong>：未提交读</p><ul><li><p>在该方式下，当前事务不需要申请任何类型的封锁，因而可能会<strong>读</strong>到未提交的修改结果</p></li><li><p>禁止一个事务以该方式去执行对数据的<strong>写</strong>操作，以避免与其它并发事务的<strong>写</strong>冲突现象</p></li></ul></li><li><p><strong>READCOMMITTED</strong>：提交读</p><ul><li>在<strong>读</strong>数据对象 A 之前需要先申请对数据对象 A 的<strong>共享性</strong>封锁，在<strong>读</strong>操作执行结束之后立即释放该封锁</li><li>以避免读取到其它并发事务未提交的修改结果</li></ul></li><li><p><strong>READREPEATABLE</strong>：可重复读</p><ul><li>在<strong>读</strong>数据对象 A 之前需要先申请对数据对象 A 的<strong>共享性</strong>封锁，并将该封锁维持到当前事务的结束</li><li>可以避免其它的并发事务对当前事务正在使用的数据对象的修改</li></ul></li><li><p><strong>SERIALIZABLE</strong>：可序列化（可串行化）</p><ul><li>并发事务以一种可串行化的调度策略实现其并发执行，以避免它们相互之间的干扰现象</li></ul></li></ul></li><li><p>不管采用何种隔离级别，在事务<strong>写</strong>数据对象 A 之前需要先申请对数据对象 A 的<strong>排它性</strong>封锁，并将该封锁维持到当前事务的结束。</p></li><li><p>事务的隔离级别与封锁策略之间的关系</p><table style="text-align: center;">  <tr>    <td rowspan="2"></td>    <th colspan="2">Read操作</th>    <th colspan="2">Write操作</th>  </tr >  <tr>    <th>锁类型</th>    <th>封锁时间</th>    <th>锁类型</th>    <th>封锁时间</th>  </tr >  <tr >    <td>READUNCOMMITTED 未提交读</td>    <td>No Lock</td>    <td>-</td>    <td colspan="2">不允许执行 Write 操作</th>  </tr>  <tr>    <td>READCOMMITTED 提交读</td>    <td>共享锁</td>    <td>读操作</td>    <td rowspan="3">排它锁</th>        <td rowspan="3">事务</th>  </tr>  <tr>    <td>READREPEATABLE 可重复读</td>    <td>共享锁</td>    <td>事务</td>  </tr>  <tr>    <td>SERIALIZABLE 可串行化</td>    <td>共享锁</td>    <td>事务</td>  </tr></table></li></ul></li></ul><h2 id="二、并发控制技术"><a href="#二、并发控制技术" class="headerlink" title="二、并发控制技术"></a>二、并发控制技术</h2><h3 id="（一）事务的并发执行"><a href="#（一）事务的并发执行" class="headerlink" title="（一）事务的并发执行"></a>（一）事务的并发执行</h3><h4 id="1-并发性"><a href="#1-并发性" class="headerlink" title="1. 并发性"></a>1. 并发性</h4><ul><li><p>数据库是一个多用户共享系统</p></li><li><p>每个用户（或用户程序）都是以‘事务’为单位访问数据库</p></li><li><p>用于实现多个用户事务的并发执行的技术被称为<strong>并发控制</strong> (Concurrent Control) 技术</p></li></ul><h4 id="2-多个事务的执行方式"><a href="#2-多个事务的执行方式" class="headerlink" title="2. 多个事务的执行方式"></a>2. 多个事务的执行方式</h4><ul><li><p>串行执行</p><ul><li><p>以事务为单位，多个事务依次顺序执行</p></li><li><p>前一个事务对数据库的访问操作执行结束后，再去处理下一个事务对数据库的访问操作</p></li></ul></li><li><p>并发执行</p><ul><li>按一定调度策略交替执行</li></ul></li><li><p>并发执行的可串行化 (Serializability)</p><ul><li>如果一组事务并发执行的结果等价于它们之间的某种串行执行的结果，则称其为可串行化调度</li></ul></li></ul><h4 id="3-并发控制的目标"><a href="#3-并发控制的目标" class="headerlink" title="3. 并发控制的目标"></a>3. 并发控制的目标</h4><ul><li>实现并发事务的可串行化调度</li></ul><p><img src="/img/posts/DB-5-3.jpg" alt="这是图片" title="用户事务并发执行示意图"></p><h4 id="4-调度"><a href="#4-调度" class="headerlink" title="4. 调度"></a>4. 调度</h4><ul><li>一个或多个事务中的数据库访问操作，按照这些操作被执行的时间排序所形成的一个操作序列</li></ul><h4 id="5-数据库访问操作"><a href="#5-数据库访问操作" class="headerlink" title="5. 数据库访问操作"></a>5. 数据库访问操作</h4><ul><li><p>用户事务对于数据库的访问操作包括<strong>READ</strong>和<strong>WRITE</strong>，这是事务对数据库缓冲区中的数据的<strong>读</strong>和<strong>写</strong>操作。</p></li><li><p>驻留在内存缓冲区中的同一个数据对象<strong>A</strong>，有可能同时被若干个事务<strong>读</strong>或<strong>写</strong>。我们在考虑一个<strong>调度</strong>时，最关心的是这一组事务以一种什么样的顺序来<strong>读&#x2F;写</strong>内存缓冲区中的数据</p></li><li><p>同一个事务的一组<strong>读&#x2F;写</strong>操作在<strong>调度</strong>中的执行顺序是固定不变的，但是并发事务的不同交叉执行方式就构成了不同的<strong>调度</strong></p></li></ul><h4 id="6-串行调度"><a href="#6-串行调度" class="headerlink" title="6. 串行调度"></a>6. 串行调度</h4><ul><li><p>如果一个调度的操作组成方式如下：首先是一个事务的所有操作，然后是另一个事务的所有操作，依此类推，则我们称该调度是串行的，或称为<strong>串行调度</strong></p></li><li><p>每一个事务中的所有操作，都是按照其预定的顺序依次执行的</p></li><li><p>任何一个串行调度均具有以下性质</p><ul><li><p>在该调度中任意取两个事务<strong>X</strong>和<strong>Y</strong>，如果<strong>X</strong>的某个操作在<strong>Y</strong>的某个操作之前，则<strong>X</strong>的所有操作都在<strong>Y</strong>的所有操作之前</p><ul><li>不存在不同事务之间的交叉执行现象</li></ul></li><li><p>并发事务的串行调度执行方式不会破坏数据库状态的一致性</p></li></ul></li></ul><h4 id="7-可串行化调度"><a href="#7-可串行化调度" class="headerlink" title="7. 可串行化调度"></a>7. 可串行化调度</h4><ul><li><p>每个串行调度都将保持数据库状态的一致性。但也存在其它的调度（非串行调度）能够保证数据库状态的一致性</p></li><li><p>如果一个调度对数据库状态的影响和某个串行调度相同，则我们称该调度是可串行化的，或称为<strong>可串行化调度</strong></p></li></ul><h4 id="8-冲突可串行化"><a href="#8-冲突可串行化" class="headerlink" title="8. 冲突可串行化"></a>8. 冲突可串行化</h4><h5 id="（1）冲突"><a href="#（1）冲突" class="headerlink" title="（1）冲突"></a>（1）冲突</h5><ul><li><p>是指调度中的一对连续操作 (op1; op2)，它们满足如下的条件：</p><ul><li>如果交换它们两者的执行顺序，那么涉及的事务中至少有一个的行为会改变</li></ul></li><li><p>符合上述条件的一对连续的操作 (op1; op2) 被称为<strong>冲突</strong></p></li></ul><h5 id="（2）冲突的判断"><a href="#（2）冲突的判断" class="headerlink" title="（2）冲突的判断"></a>（2）冲突的判断</h5><ul><li><p>假设$T_i$和$T_j$是两个不同的事务（即$i\neq j$），则：</p><ul><li>$r_i(X);r_j(Y)$不是冲突（即使$X&#x3D;Y$ 也不会是冲突）</li><li>如果$X\neq Y$，则 $r_i(X);w_j(Y) $ 不会是冲突</li><li>如果$X\neq Y$，则 $w_i(X);r_j(Y) $ 不会是冲突</li><li>如果$X\neq Y$，则 $w_i(X);w_j(Y) $ 不会是冲突</li></ul></li><li><p>同一事务的任意两个相邻的操作都是冲突，如：</p><ul><li>$(r_i(X);w_i(Y))$、$(w_i(X);r_i(Y))$、$(r_i(X);r_i(Y))$等</li></ul></li><li><p>不同事务对同一数据对象的<strong>写</strong>冲突：</p><ul><li>$w_i(X);w_j(X)$</li></ul></li><li><p>不同事务对同一数据对象的<strong>读-写</strong>冲突：</p><ul><li>$r_i(X);w_j(X)\quad w_i(X);r_j(X)$</li></ul></li><li><p>因此</p><ul><li>同一事务中的任意两个操作不可以交换它们的执行顺序（是冲突）</li><li>不同事务中的任何两个操作在执行顺序上是可以交换的，除非：<ul><li>它们涉及同一个数据对象；并且</li><li>至少有一个是<strong>写</strong>操作</li></ul></li></ul></li><li><p>对于初始给定的一个调度，如果通过一组<strong>非冲突</strong>操作的交换，能够将该调度转换为一个串行调度，则我们认为最初的调度就是一个可串行化调度</p></li></ul><h5 id="（3）冲突等价"><a href="#（3）冲突等价" class="headerlink" title="（3）冲突等价"></a>（3）冲突等价</h5><ul><li>如果通过一系列相邻操作的非冲突交换能够将一个调度转换为另一个调度，则我们称这两个调度是冲突等价的</li></ul><h5 id="（4）冲突可串行化"><a href="#（4）冲突可串行化" class="headerlink" title="（4）冲突可串行化"></a>（4）冲突可串行化</h5><ul><li>如果一个调度 S 冲突等价于一个串行调度，则我们称调度 S 是<strong>冲突可串行化</strong>的</li></ul><h5 id="（5）优先图"><a href="#（5）优先图" class="headerlink" title="（5）优先图"></a>（5）优先图</h5><ul><li><p>思想：冲突操作反映了给定事务在冲突等价的串行调度（如果存在的话）中的执行顺序</p></li><li><p>定义：已知在调度 $S$ 中存在两个事务 $T_1$ 和 $T_2 $，如果有 $T_1$ 的一个动作 $A_1$  和  $T_2 $ 的一个动作  $A_2 $ 满足：</p><ul><li>在调度 $S$ 中 $A_1$ 在 $A_2$ 前</li><li>$A_1$ 和 $A_2$ 涉及数据库中的同一数据对象，且至少有一个是<strong>写</strong>动作</li></ul><p>则我们称 $T_1$ 优先于 $T_2$ ，记为 $T_1&lt;_s T_2$</p></li><li><p>在上述情况下， $A_1$ 和 $A_2$ 是两个不能交换的动作，如果存在一个冲突等价于 $S$ 的串行调度，则在该串行调度中 $T_1$ 必在 $T_2$ 之前</p></li><li><p>以调度 $S$ 中的事务作为优先图中的结点（事务 $T_i$ 可简记为 $i$ ），如果$T_i&lt;_s T_j$，则从结点 $i$ 到结点 $j$ 引一条有向边。依此类推构成的一个有向图被称为调度 $S$ 的事务优先图。</p><ul><li><p>例：$r_2 (A); r_1 (B); w_2 (A); r_2 (B); r_3 (A); w_1 (B); w_3 (A); w_2 (B)$</p><ul><li><p>第一步：从调度 $S$ 中找出所有与数据对象 A 有关的操作<br>$$<br>r_2 (A); w_2 (A); r_3 (A); w_3 (A);<br>$$</p><ul><li>根据冲突 $(w_2(A);r_3(A))$ 可知：存在从事务 2 到事务 3 的一条有向边</li></ul></li><li><p>第二步：从调度 $S$​ 中找出所有与数据对象 B 有关的操作<br>$$<br>r_1 (B); r_2 (B); w_1 (B); w_2 (B);<br>$$</p><ul><li>根据冲突 $(r_2(B);w_1(B))$ 可知：存在从事务 2 到事务 1 的一条有向边</li><li>根据冲突 $(w_1(B);w_2(B))$ 可知：存在从事务 1 到事务 2 的一条有向边</li></ul></li><li><p>因此其优先图是：$1\rightleftharpoons2 \to 3$</p></li></ul></li></ul></li></ul><h5 id="（6）冲突可串行性判断规则"><a href="#（6）冲突可串行性判断规则" class="headerlink" title="（6）冲突可串行性判断规则"></a>（6）冲突可串行性判断规则</h5><ul><li>构造调度 $S$ 的事务优先图，如果该图是无环的，则调度 $S$ 是冲突可串行化的。如果有环，则调度 $S$ 不是冲突可串行化的</li></ul><h4 id="9-三种数据不一致现象"><a href="#9-三种数据不一致现象" class="headerlink" title="9. 三种数据不一致现象"></a>9. 三种数据不一致现象</h4><h5 id="（1）丢失修改（-lost-updata-）"><a href="#（1）丢失修改（-lost-updata-）" class="headerlink" title="（1）丢失修改（ lost updata ）"></a>（1）丢失修改（ lost updata ）</h5><ul><li><p>现象：一个事务的修改结果破坏了另一个事务的修改结果</p></li><li><p>原因：对多个事务并发修改同一个数据对象的情况未加控制</p></li></ul><h5 id="（2）脏读（-dirty-read-）"><a href="#（2）脏读（-dirty-read-）" class="headerlink" title="（2）脏读（ dirty read ）"></a>（2）脏读（ dirty read ）</h5><ul><li><p>现象：读到了错误的数据（即与数据库中的情况不相符的数据）</p></li><li><p>原因：一个事务读取了另一个事务未提交的修改结果</p></li></ul><h5 id="（3）不可重复读（-non-repeatable-read-）"><a href="#（3）不可重复读（-non-repeatable-read-）" class="headerlink" title="（3）不可重复读（ non-repeatable read ）"></a>（3）不可重复读（ non-repeatable read ）</h5><ul><li><p>现象：在一个事务的执行过程中，前后两次读同一个数据对象所获得的值出现了不一致</p></li><li><p>原因：在两次<strong>读</strong>操作之间插入了另一个事务的<strong>写</strong>操作</p></li></ul><h3 id="（二）封锁"><a href="#（二）封锁" class="headerlink" title="（二）封锁"></a>（二）封锁</h3><h4 id="1-封锁（lock）"><a href="#1-封锁（lock）" class="headerlink" title="1. 封锁（lock）"></a>1. 封锁（lock）</h4><ul><li><p>使用封锁技术的前提</p><ul><li>在一个事务访问数据库中的数据时，必须先获得被访问的数据对象上的封锁，以保证数据访问操作的正确性和一致性。</li></ul></li><li><p>封锁的作用</p><ul><li><p>在一段时间内禁止其它事务在被封锁的数据对象上执行某些类型的操作（由封锁的类型决定）</p></li><li><p>同时也表明：持有该封锁的事务在被封锁的数据对象上将要执行什么类型的操作（由系统所采用的封锁协议来决定）</p></li></ul></li><li><p><strong>封锁</strong>是多用户环境中最常采用的一种并发控制技术</p></li></ul><h4 id="2-封锁类型"><a href="#2-封锁类型" class="headerlink" title="2. 封锁类型"></a>2. 封锁类型</h4><h5 id="（1）排它锁"><a href="#（1）排它锁" class="headerlink" title="（1）排它锁"></a>（1）排它锁</h5><ul><li><p>e<strong>X</strong>clusive lock，又简称为：<strong>X</strong>锁</p></li><li><p>特性</p><ul><li>只有当数据对象 A 没有被其它事务封锁时，事务 T 才能在数据对象 A 上施加 <strong>X 锁</strong></li><li>如果事务 T 对数据对象 A 施加了 <strong>X 锁</strong>，则其它任何事务都不能在数据对象 A 上再施加任何类型的封锁</li></ul></li><li><p>作用</p><ul><li><p>如果一个事务 T 申请在数据对象 A 上施加 <strong>X锁</strong> 并得到满足，则：事务 T 自身可以对数据对象 A 作读、写操作，而其它事务则被禁止访问数据对象 A</p></li><li><p>这样可以让事务 T 独占该数据对象 A ，从而保证了事务 T 对数据对象 A 的访问操作的正确性和一致性</p></li><li><p>缺点：降低了整个系统的并行性</p></li></ul></li><li><p><strong>X锁</strong> 必须维持到事务 T 的执行结束</p></li></ul><h5 id="（2）共享锁"><a href="#（2）共享锁" class="headerlink" title="（2）共享锁"></a>（2）共享锁</h5><ul><li><p><strong>S</strong>haring lock，又简称为：<strong>S</strong>锁</p></li><li><p>特性</p><ul><li>如果数据对象 A 没有被其它事务封锁，或者其它事务仅仅以 <strong>S锁</strong> 的方式来封锁数据对象 A 时，事务 T 才能在数据对象 A 上施加 <strong>S锁</strong></li></ul></li><li><p>作用</p><ul><li>如果一个事务 T 申请在数据对象 A 上施加 <strong>S锁</strong> 并得到满足，则： 事务 T 可以 <strong>读</strong> 数据对象 A 但不能 <strong>写</strong> 数据对象 A</li><li>不同事务所申请的 <strong>S锁</strong> 可以共存于同一个数据对象 A 上，从而保证了多个事务可以同时 读 数据对象 A ，有利于提高整个系统的并发性</li><li>在持有封锁的事务释放数据对象 A 上的所有 <strong>S锁</strong>之前，任何事务都不能 <strong>写</strong> 数据对象 A</li></ul></li><li><p><strong>S锁</strong> 不必维持到事务 T 的执行结束（依封锁协议而定）</p></li></ul><h5 id="（3）锁相容矩阵"><a href="#（3）锁相容矩阵" class="headerlink" title="（3）锁相容矩阵"></a>（3）锁相容矩阵</h5><table style="text-align: center;">  <tr>    <td rowspan="2" colspan="2"></td>    <th colspan="3">其他事务已持有的锁</th>  </tr >  <tr>    <th>X锁</th>    <th>S锁</th>    <th>-</th>  </tr >  <tr >    <td rowspan="2">当前事务申请的锁</td>    <td>X锁</td>    <td>No</td>    <td>No</td>    <td>Yes</td>  </tr>  <tr>    <td>S锁</td>    <td>No</td>    <td>Yes</td>    <td>Yes</td>  </tr></table><h4 id="3-合适-well-formed-事务"><a href="#3-合适-well-formed-事务" class="headerlink" title="3. 合适 (well formed) 事务"></a>3. 合适 (well formed) 事务</h4><ul><li>如果一个事务在访问数据库中的数据对象 A 之前按照要求申请对 A 的封锁，在操作结束后释放 A 上的封锁，这种事务被称为合适事务</li><li><strong>合适事务</strong>是保证并发事务的正确执行的基本条件</li></ul><h4 id="4-封锁的申请与释放"><a href="#4-封锁的申请与释放" class="headerlink" title="4. 封锁的申请与释放"></a>4. 封锁的申请与释放</h4><ul><li><p>封锁管理器的数据结构</p><ul><li><p>数组<strong>LOCK(A)</strong></p><ul><li>记录被施加在数据对象 A 上的封锁类型，其值是：<ul><li><strong>Read_locked</strong>（共享锁）</li><li><strong>Write_locked</strong>（排它锁）</li><li><strong>Unlocked</strong>（无封锁）</li></ul></li></ul></li><li><p>数组<strong>no_of_reads(A)</strong></p><ul><li>记录被施加在数据对象 A 上的共享锁的个数</li></ul></li></ul></li></ul><h3 id="（三）封锁协议"><a href="#（三）封锁协议" class="headerlink" title="（三）封锁协议"></a>（三）封锁协议</h3><h4 id="1-一级封锁协议"><a href="#1-一级封锁协议" class="headerlink" title="1. 一级封锁协议"></a>1. 一级封锁协议</h4><ul><li>事务 T 在<strong>写</strong>数据对象 A 之前，必须先申请并获得 A 上的 <strong>X锁</strong>，并维持到事务 T 的执行结束（包括Commit与Rollback）才释放被加在 A 上的 <strong>X锁</strong></li></ul><h4 id="2-二级封锁协议"><a href="#2-二级封锁协议" class="headerlink" title="2. 二级封锁协议"></a>2. 二级封锁协议</h4><ul><li><p><strong>一级封锁协议</strong>的要求；并且</p></li><li><p>事务 T 在<strong>读</strong>数据对象 A 之前，必须先申请并获得 A 上的 <strong>S锁</strong>，在<strong>读</strong>操作完成后即可释放 A 上的 <strong>S锁</strong></p><ul><li>这里没有规定释放 <strong>S锁</strong> 的时间</li></ul></li></ul><h4 id="3-三级封锁协议"><a href="#3-三级封锁协议" class="headerlink" title="3. 三级封锁协议"></a>3. 三级封锁协议</h4><ul><li><strong>一级封锁协议</strong>的要求；并且</li><li>事务 T 在<strong>读</strong>数据对象 A 之前，必须先申请并获得 A上的 <strong>S锁</strong>，并维持到事务 T 的执行结束（包括Commit 与 Rollback）才释放被加在 A 上的 <strong>S锁</strong></li></ul><h4 id="4-三级封锁协议与三种数据不一致现象的关系"><a href="#4-三级封锁协议与三种数据不一致现象的关系" class="headerlink" title="4. 三级封锁协议与三种数据不一致现象的关系"></a>4. 三级封锁协议与三种数据不一致现象的关系</h4><table style="text-align: center;">  <tr>    <td rowspan="2" colspan="2"></td>    <th colspan="3">可能出现的数据不一致现象</th>  </tr >  <tr>    <th>丢失修改</th>    <th>脏读</th>    <th>不可重复读</th>  </tr >  <tr >    <td rowspan="3">封锁协议</td>    <td>一级封锁协议</td>    <td>No</td>    <td>Yes</td>    <td>Yes</td>  </tr>  <tr>    <td>二级封锁协议</td>    <td>No</td>    <td>No</td>    <td>Yes</td>  </tr>  <tr>    <td>三级封锁协议</td>    <td>No</td>    <td>No</td>    <td>No</td>  </tr></table><h3 id="（四）两阶段封锁协议"><a href="#（四）两阶段封锁协议" class="headerlink" title="（四）两阶段封锁协议"></a>（四）两阶段封锁协议</h3><h4 id="1-两阶段封锁协议（two-phase-locking-protocol，简称2PL协议）"><a href="#1-两阶段封锁协议（two-phase-locking-protocol，简称2PL协议）" class="headerlink" title="1. 两阶段封锁协议（two-phase locking protocol，简称2PL协议）"></a>1. 两阶段封锁协议（two-phase locking protocol，简称2PL协议）</h4><h5 id="（1）第一个阶段：申请并获得封锁"><a href="#（1）第一个阶段：申请并获得封锁" class="headerlink" title="（1）第一个阶段：申请并获得封锁"></a>（1）第一个阶段：申请并获得封锁</h5><ul><li>在此阶段中，事务可以申请其整个执行过程中所需要的锁，此阶段也可称为<strong>扩展阶段</strong></li></ul><h5 id="（2）第二个阶段：释放所有申请获得的锁"><a href="#（2）第二个阶段：释放所有申请获得的锁" class="headerlink" title="（2）第二个阶段：释放所有申请获得的锁"></a>（2）第二个阶段：释放所有申请获得的锁</h5><ul><li>事务一旦开始释放封锁，那么就不能再申请任何封锁，此阶段也可称为<strong>收缩阶段</strong></li></ul><h4 id="2-两阶段封锁事务"><a href="#2-两阶段封锁事务" class="headerlink" title="2. 两阶段封锁事务"></a>2. 两阶段封锁事务</h4><ul><li><p>在一个事务 T 中，如果所有的封锁请求都先于所有的解锁请求，则该事务被称为<strong>两阶段封锁事务</strong>，简称<strong>2PL事务</strong></p></li><li><p>用 sl(A) 表示申请对 A 的 <strong>S锁</strong>，用 xl(A) 表示申请对 A 的 <strong>X 锁</strong>，用 u(A) 表示释放 A 上的封锁</p></li><li><p>2PL 事务的例子</p><div align=center><img src="/img/posts/DB-5-4.jpg" title="2PL 事务的例子" height="75%" width="75%" /></div></li><li><p>不遵守 2PL 协议的例子</p><div align=center><img src="/img/posts/DB-5-5.jpg" title="不遵守 2PL 协议的例子" height="75%" width="75%" /></div></li></ul><h4 id="3-有关封锁技术的使用规定"><a href="#3-有关封锁技术的使用规定" class="headerlink" title="3. 有关封锁技术的使用规定"></a>3. 有关封锁技术的使用规定</h4><ul><li><p>假设系统采用 <strong>X 锁</strong> 和 <strong>S 锁</strong> 两种类型锁，有关封锁的申请与释放操作表示如下：</p><ul><li>$sl_i(A)$：事务 $T_i$ 申请数据对象 $A$ 上的一个 <strong>S 锁</strong></li><li>$xl_i(A)$：事务 $T_i$ 申请数据对象 $A$ 上的一个 <strong>X 锁</strong></li><li>也可以用 $l_i(A)$ 表示事务 $T_i$ 申请数据对象 $A$ 上的锁</li><li>$u_i(A)$：事务 $T_i$ 释放自己在数据对象 $A$ 上所持有的锁</li></ul></li><li><p>在每一个事务$T_i$中</p><ul><li><p>第1点 ：采用如下的封锁协议</p><ul><li>读动作 $r_i (A) $之前必须有 $sl_i (A)$ 或 $xl_i ( A)$，而且在两者之间没有 $u_i(A)$</li><li>写动作 $w_i (A)$ 之前必须有 $xl_i (A)$，而且在两者之间没有 $u_i(A)$</li><li>每一个 $sl_i (A)$ 或 $xl_i (A)$ 之后必须有一个 $u_i(A)$</li></ul></li><li><p>第2点：必须遵循<strong>两阶段封锁协议</strong></p><ul><li><p>在任何$sl_i(A)$或$xl_i(A)$之前不能有$u_i(B)$</p></li><li><p>$A$和$B$可以是同一个数据对象</p></li></ul></li><li><p>如果事务 $T_i$ 在执行过程中重复申请同一个数据对象 $A$ 上的锁， <strong>封锁管理器</strong> 的处理方法如下：</p><ul><li>如果 $T_i$ 已经持有数据对象 $A$ 上的锁，则对 $sl_i(A)$不作任何处理</li><li>如果 $T_i$ 已经持有数据对象 $A$ 上的 **S 锁 **，在处理$xl_i(A)$请求时，仅仅将 $T_i$ 所持有的 <strong>S 锁</strong> 改为 <strong>X 锁</strong><ul><li>仅当 <strong>只有</strong> 事务 $T_i$ 持有数据对象 $A$ 上的 <strong>S 锁</strong> 时，封锁管理器才能将 $T_i$ 所持有的 <strong>S 锁</strong> 改为 <strong>X 锁</strong></li></ul></li><li>如果 $T_i$ 已经持有数据对象 $A$ 上的 <strong>X 锁</strong>，则对 $xl_i(A)$不作任何处理</li></ul></li><li><p>第3点：保证事务调度的合法性</p><ul><li><p>对任意两个不同的事务 $T_i$ 和 $T_j$ ，其调度必须满足：</p><ul><li><p>如果$xl_i(A)$出现在调度中，那么后面不能再有$sl_j(A)$或$xl_j(A)$，除非中间插入了$u_i(A)$</p></li><li><p>如果$sl_i(A)$出现在调度中，那么后面不能再有$xl_j(A)$，除非中间插入了$u_i(A)$</p></li></ul></li></ul></li></ul></li></ul><h4 id="4-定理"><a href="#4-定理" class="headerlink" title="4. 定理"></a>4. 定理</h4><ul><li>由 2PL 事务所构成的任意合法调度 S 都是冲突可串行化的</li></ul><h3 id="（五）封锁粒度"><a href="#（五）封锁粒度" class="headerlink" title="（五）封锁粒度"></a>（五）封锁粒度</h3><h4 id="1-封锁粒度（Granularity）"><a href="#1-封锁粒度（Granularity）" class="headerlink" title="1. 封锁粒度（Granularity）"></a>1. 封锁粒度（Granularity）</h4><ul><li><p>一把锁可以封锁的数据对象的大小</p></li><li><p>锁的封锁对象可以是数据库中的逻辑数据单元，也可以是物理数据单元</p></li><li><p>以关系数据库系统为例，可以采用的封锁粒度有：</p><ul><li><p>逻辑数据单元</p><ul><li>属性值（集合），元组，关系</li><li>索引项，索引文件</li><li>整个数据库</li></ul></li><li><p>物理数据单元</p><ul><li>页，块</li></ul></li></ul></li><li><p><strong>封锁粒度</strong> 与 <strong>并发控制的开销</strong> 的关系</p></li></ul><table><thead><tr><th align="center">封锁粒度</th><th align="center">系统并发度</th><th align="center">并发控制的开销</th></tr></thead><tbody><tr><td align="center">大</td><td align="center">低</td><td align="center">小</td></tr><tr><td align="center">小</td><td align="center">高</td><td align="center">大</td></tr></tbody></table><h4 id="2-多粒度封锁（Multiple-Granularity-Locking）"><a href="#2-多粒度封锁（Multiple-Granularity-Locking）" class="headerlink" title="2. 多粒度封锁（Multiple Granularity Locking）"></a>2. 多粒度封锁（Multiple Granularity Locking）</h4><ul><li><p>如果在一个系统中同时支持多种封锁粒度供事务选择使用，这种封锁方法被称为<strong>多粒度封锁</strong></p></li><li><p>通过选择合适的<strong>封锁粒度</strong>来达到如下目的：</p><ul><li>通过加大<strong>封锁粒度</strong>来减少<strong>锁</strong>的数量，降低并发控制的开销</li><li>通过降低<strong>封锁粒度</strong>来缩小一把锁可以封锁的数据范围，减少封锁冲突现象，提高系统并发度</li></ul></li><li><p>可以按照封锁粒度的大小构造出一棵<strong>多粒度树</strong>，以树中的每个结点作为封锁对象，可以构成一个 多粒度封锁协议</p></li><li><p>多粒度封锁协议</p><ul><li><p>可以对<strong>多粒度树</strong>中的每个结点独立加锁（显式封锁）</p></li><li><p>对一个结点加锁意味着该结点的所有后裔结点也被加以同样类型的锁（隐式封锁）</p></li></ul></li></ul><h4 id="3-意向锁（Intention-Lock）"><a href="#3-意向锁（Intention-Lock）" class="headerlink" title="3. 意向锁（Intention Lock）"></a>3. 意向锁（Intention Lock）</h4><ul><li><p><strong>意向锁</strong>的使用规定</p><ul><li><p>如果对一个结点加<strong>意向锁</strong>，则说明该结点的下层结点正在被加锁</p></li><li><p>对任一结点加锁时，必须先对它的上层结点加<strong>意向锁</strong></p></li></ul></li><li><p>三种常见的<strong>意向锁</strong></p><ul><li><p>意向共享锁（<strong>IS</strong>锁）</p></li><li><p>意向排它锁（<strong>IX</strong>锁）</p></li><li><p>共享意向排它锁（<strong>SIX</strong>锁）</p></li></ul></li><li><p>可以联合使用上述三种意向锁和原有的<strong>S锁</strong>、<strong>X锁</strong>共同实现基于封锁技术的并发控制</p></li><li><p>意向共享锁（ IS 锁）</p><ul><li>如果对结点 N 加 <strong>IS 锁</strong>，表示准备在结点 N 的某些后裔结点上加 <strong>S 锁</strong></li></ul></li><li><p>意向排它锁（ IX 锁）</p><ul><li>如果对结点 N 加 <strong>IX 锁</strong>，表示准备在结点 N 的某些后裔结点上加 <strong>X 锁</strong></li></ul></li><li><p>共享意向排它锁（ SIX 锁）</p><ul><li>如果对结点 N 加 <strong>SIX 锁</strong>，表示对结点 N 本身加 <strong>S 锁</strong>，并准备在 N 的某些后裔结点上加 <strong>X 锁</strong></li></ul></li></ul><table style="text-align: center;">  <tr>    <td rowspan="2" colspan="2"></td>    <th colspan="5">其他事务已持有的锁</th>  </tr >  <tr>    <th>S锁</th>    <th>X锁</th>    <th>IS锁</th>    <th>IX锁</th>    <th>SIX锁</th>  </tr >  <tr >    <td rowspan="5">当前事务申请的锁</td>    <td>S锁</td>    <td>Yes</td>    <td>No</td>    <td>Yes</td>    <td>No</td>    <td>No</td>  </tr>  <tr>    <td>X锁</td>    <td>No</td>    <td>No</td>    <td>No</td>    <td>No</td>    <td>No</td>  </tr>  <tr>    <td>IS锁</td>    <td>Yes</td>    <td>No</td>    <td>Yes</td>    <td>Yes</td>    <td>Yes</td>  </tr>  <tr>    <td>IX锁</td>    <td>No</td>    <td>No</td>    <td>Yes</td>    <td>Yes</td>    <td>No</td>  </tr>  <tr>    <td>SIX锁</td>    <td>No</td>    <td>No</td>    <td>Yes</td>    <td>No</td>    <td>No</td>  </tr></table><ul><li>具有<strong>意向锁</strong>的多粒度封锁方法的优点<ul><li>减少了 <strong>加锁</strong> 和 <strong>解锁</strong> 的开销</li><li>提高了系统的并发度</li></ul></li></ul><h3 id="（六）活锁与死锁"><a href="#（六）活锁与死锁" class="headerlink" title="（六）活锁与死锁"></a>（六）活锁与死锁</h3><h4 id="1-死锁（deadlock）"><a href="#1-死锁（deadlock）" class="headerlink" title="1. 死锁（deadlock）"></a>1. 死锁（deadlock）</h4><ul><li><p>每个事务都可能拥有一部分锁，并因申请其它事务所持有的锁而等待，因此产生的循环等待现象被称为<strong>死锁</strong></p></li><li><p>死锁问题的处理办法</p><ul><li><p>预防法</p><ul><li><p>采用一定的锁申请操作方式以避免死锁现象的发生</p><ul><li><p>顺序申请法</p></li><li><p>一次申请法</p></li></ul></li></ul></li><li><p>解除法</p><ul><li>允许产生死锁，当系统通过<strong>死锁检测</strong>程序发现出现死锁现象时，可以调用解锁程序来解除死锁<ul><li>超时死锁检测法<ul><li>事务的执行时间超时</li><li>锁申请的等待时间超时</li></ul></li><li>等待图法</li><li>时间戳死锁检测法</li></ul></li></ul></li></ul></li></ul><h4 id="2-活锁（livelock）"><a href="#2-活锁（livelock）" class="headerlink" title="2. 活锁（livelock）"></a>2. 活锁（livelock）</h4><ul><li>有部分事务因封锁申请得不到满足而处于长期等待状态，但其它的事务仍然可以继续运行下去，这种情况被称为<strong>活锁</strong></li><li>解决方法<ul><li>先来先服务</li></ul></li></ul><h2 id="三、数据库恢复技术"><a href="#三、数据库恢复技术" class="headerlink" title="三、数据库恢复技术"></a>三、数据库恢复技术</h2><h3 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h3><h4 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h4><ul><li><p>在数据库遭受破坏后及时进行恢复的功能</p></li><li><p>方法</p><ul><li>利用数据冗余原理，将数据库中的数据在不同的存储介质上进行冗余存储，当数据库本身受到破坏时，可以利用这些冗余信息进行恢复</li></ul></li><li><p>常用措施</p><ul><li><p>数据转储</p></li><li><p>日志</p></li><li><p>数据库镜像</p></li></ul></li></ul><h3 id="（二）数据库故障分类"><a href="#（二）数据库故障分类" class="headerlink" title="（二）数据库故障分类"></a>（二）数据库故障分类</h3><h4 id="1-小型故障"><a href="#1-小型故障" class="headerlink" title="1. 小型故障"></a>1. 小型故障</h4><ul><li>事务内部故障<ul><li>故障的影响范围在一个事务之内，不影响整个系统的正常运行</li></ul></li></ul><h4 id="2-中型故障"><a href="#2-中型故障" class="headerlink" title="2. 中型故障"></a>2. 中型故障</h4><ul><li><p>系统故障</p></li><li><p>外部影响</p><ul><li>可导致整个系统停止工作，但磁盘数据不受影响。在系统重启时，可通过当前的日志文件进行恢复</li></ul></li></ul><h4 id="3-大型故障"><a href="#3-大型故障" class="headerlink" title="3. 大型故障"></a>3. 大型故障</h4><ul><li><p>磁盘故障</p></li><li><p>计算机病毒</p></li><li><p>黑客入侵</p><ul><li>可导致内存及磁盘数据的严重破坏，需要对数据库做彻底的恢复</li></ul></li></ul><h3 id="（三）数据库故障恢复三大技术"><a href="#（三）数据库故障恢复三大技术" class="headerlink" title="（三）数据库故障恢复三大技术"></a>（三）数据库故障恢复三大技术</h3><h4 id="1-数据转储（dump）"><a href="#1-数据转储（dump）" class="headerlink" title="1. 数据转储（dump）"></a>1. 数据转储（dump）</h4><ul><li><p>定期地将数据库中的内容复制到其它存储设备中去的过程</p></li><li><p>后备（后援）副本：经转储而得到的备份数据</p></li><li><p>转储的分类</p><ul><li><p>静态转储 vs 动态转储</p></li><li><p>海量转储 vs 增量转储</p></li></ul></li></ul><h4 id="2-日志（log）"><a href="#2-日志（log）" class="headerlink" title="2. 日志（log）"></a>2. 日志（log）</h4><h5 id="（1）日志"><a href="#（1）日志" class="headerlink" title="（1）日志"></a>（1）日志</h5><ul><li><p>是由数据库系统创建和维护的，用于自动记载数据库中修改型操作的数据更新情况的文件</p></li><li><p>日志的内容</p><ul><li><p>每个更新操作的事务标识、更新对象、更新前的值和 &#x2F; 或更新后的值</p></li><li><p>每个事务的开始、结束等执行情况</p></li><li><p>其它信息</p></li></ul></li><li><p>日志的组成</p><ul><li>日志是<strong>日志记录</strong>的一个序列，每个<strong>日志记录</strong>记载有关某个事务已执行操作的情况。由于日志主要用于 DB 的故障恢复，所以这里记载的主要是事务的更新操作的执行情况</li><li>由于事务通常是并发执行的，所以多个事务的日志记录通常是交错在一起的</li></ul></li><li><p>日志的作用</p><ul><li>确保事务执行的原子性</li><li>实现增量转储</li><li>实现故障恢复<ul><li>在发生系统故障时，为了修复故障所产生的影响，某些事务的操作将会被重做（ redo ），而另一些事务的操作将会被撤消（ undo）</li><li>为了区分哪些事务将被重做，哪些事务将被撤消，在日志中需要记载每个事务的结束标志：<ul><li>提交（ commit ）：将被重执</li><li>放弃（ abort ）：将被撤消</li></ul></li><li>在日志中尚未有结束标志的事务，在进行故障恢复时将等同于被放弃的事务看待</li></ul></li></ul></li><li><p>日志的书写原则</p><ul><li>按照操作执行的先后次序，遵循先写日志，后修改数据库的原则</li></ul></li><li><p>几种不同的日志</p><ul><li>undo 日志<ul><li>用于被放弃事务（包括在发生故障时尚未结束的事务）的撤消工作</li></ul></li><li>redo 日志<ul><li>用于已提交事务的重做工作</li></ul></li></ul></li></ul><h5 id="（2）undo-日志"><a href="#（2）undo-日志" class="headerlink" title="（2）undo 日志"></a>（2）undo 日志</h5><ul><li><p>undo 日志的记录格式</p><ul><li>开始一个事务：&lt;Start T&gt;</li><li>提交事务 T：&lt;Commit T&gt;</li><li>放弃事务 T：&lt;Abort T&gt;</li><li>更新记录：&lt;T, X, V&gt;<ul><li>事务 T 修改了数据库元素 X 的值，而 X 的旧值是 V</li></ul></li></ul></li><li><p>undo 日志的记载规则</p><ul><li>$U_1$：如果事务 T 修改了数据库元素 X ，则更新日志 &lt;T, X,V&gt; 必须在 X 的新值写到磁盘前写到磁盘</li><li>$U_2$：如果事务 T 提交，则日志记录 &lt;Commit&gt; 必须在事务 T 改变的所有 DB 元素已写到磁盘后再写到磁盘</li></ul></li><li><p>使用 undo 日志的恢复过程</p><ul><li>将所有事务划分为两个集合<ul><li>已提交事务：有 &lt;Start&gt; 和 &lt;Commit&gt;</li><li>未提交事务：有 &lt;Start&gt; 但没有 &lt;Commit&gt;</li></ul></li><li>从 undo 日志的尾部开始向后（日志头部）扫描整个日志，对每一条更新记录 &lt;T, X, V&gt; 作如下处理：<ul><li>如果 &lt;Commit&gt; 已被扫描到，则继续扫描下一条日志记录（基于规则$U_2$）</li><li>否则，由恢复管理器将数据库中 X 的值改为 V（基于规则$U_1$）</li></ul></li><li>在日志的尾部为每个未结束事务写入一条日志记录 &lt;Abort T&gt;，并刷新日志 (Flush Log)</li></ul></li><li><p>检查点（ checkpoint）</p><ul><li><p>上述恢复过程需要扫描整个 undo 日志文件，为了降低数据库故障恢复的开销，可以定期地在日志文件中插入检查点</p></li><li><p>在日志中插入检查点的处理过程包括：</p><ul><li>系统停止接受<strong>启动新事务的请求</strong></li><li>等到所有当前活跃的事务被提交或中止，并且在日志中写入了 &lt;Commit&gt; 或 &lt;Abort&gt; 记录</li><li>将日志记录刷新到磁盘</li><li>写入日志记录 &lt;CKPT&gt;，并再次刷新日志</li><li>重新开始接受新的事务</li></ul></li><li><p>在故障恢复时，只要逆向扫描到第一条 &lt;CKPT&gt; 记录（最后一个被记入的检查点）就可以结束故障恢复工作</p></li><li><p>非静止检查点</p><ul><li>在设置检查点的过程中，允许新的事务进入系统</li></ul></li><li><p>设置<strong>非静止检查点</strong>的步骤包括</p><ul><li><p>写入日志记录&lt;Start CKPT(T1,…,Tk)&gt;，并刷新日志；其中：T1,…,Tk是当前所有活跃事务的标识符</p></li><li><p>等待T1,…,Tk中的每一个事务的提交或中止，但允许开始执行其它新的事务</p></li><li><p>当T1,…,Tk都已经完成时，写入日志记录&lt;End CKPT&gt;并刷新日志</p></li></ul></li><li><p>带有非静止检查点日志的恢复</p><ul><li><p>从日志尾部向后（日志头部）扫描日志文件进行故障恢复</p></li><li><p>可能会出现以下的两种情况：</p><ul><li><p>先遇到 &lt;End CKPT&gt; 记录</p><ul><li>继续向后扫描，直到出现与之相对应的 &lt;StartCKPT(…)&gt; 记录就可以结束故障恢复工作，在这之后的日志记录是没有用处的，可以被抛弃</li></ul></li><li><p>先遇到 &lt;Start CKPT(T1, … , Tk)&gt; 记录，此种情况下的故障恢复工作需要撤消两类事务的操作：</p><ul><li><p>在&lt;Start CKPT(T1,**…**,Tk)&gt;记录之后启动的事务</p><ul><li>在扫描到&lt;Start CKPT(T1,**…**,Tk)&gt;记录时，这类事务的操作已经被撤消</li></ul></li><li><p>T1,<strong>…</strong>,Tk中在系统崩溃前尚未完成的事务</p><ul><li>继续向后扫描日志，直至其中未完成事务的访问操作被全部撤消</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>undo 日志的不足</p><ul><li>在将事务改变的所有数据写到磁盘前不能提交该事务</li><li>上述要求将会导致：在事务的提交过程中需要执行许多<strong>写</strong>磁盘操作，从而增加了事务提交的时间开销</li></ul></li></ul><h5 id="（3）redo-日志"><a href="#（3）redo-日志" class="headerlink" title="（3）redo 日志"></a>（3）redo 日志</h5><ul><li><p>redo 日志的记录格式</p><ul><li>redo 日志的记录格式与 undo 日志一样，唯一的区别是： 在更新记录 &lt;T, X, V&gt;中记载的是更新后的值</li></ul></li><li><p>redo 日志的记载规则</p><ul><li>$R_1$：在修改磁盘上的任何数据库元素 X 之前，要保证所有与 X 的这一修改有关的日志记录（包括更新记录 &lt;T, X, V&gt; 和提交记录 &lt;Commit&gt; ）都必须出现在磁盘上</li></ul></li><li><p>使用redo日志的恢复过程</p><ul><li><p>确定所有已提交的事务</p></li><li><p>从日志文件的首部开始扫描日志，对遇到的每一条更新记录&lt;T, X, V&gt;：</p><ul><li><p>如果T是未提交事务，则继续扫描日志</p></li><li><p>如果T是已提交的事务，则为数据库元素X写入新值V</p></li></ul></li><li><p>对每个未完成的事务T，在日志的尾部写入结束标志&lt;Abort T&gt;并刷新日志</p></li></ul></li><li><p>在 redo 日志中插入（非静止）检查点的步骤</p><ul><li>写入日志记录 &lt;Start CKPT(T1 ,…,Tk )&gt;，并刷新日志；<ul><li>其中：T1 ,…,Tk 是当前所有活跃事务的标识符</li><li>同时获得当时所有已提交事务的标识符集合 S</li></ul></li><li>将集合 S 中的事务已经写到内存缓冲区但还没有写到数据库磁盘的数据库元素写入磁盘；</li><li>写入日志记录 &lt;End CKPT&gt;并刷新日志<ul><li>不必等待事务 T1 ,…,Tk 或新开始事务的结束</li></ul></li></ul></li></ul><h5 id="（4）redo日志与undo日志的主要区别"><a href="#（4）redo日志与undo日志的主要区别" class="headerlink" title="（4）redo日志与undo日志的主要区别"></a>（4）redo日志与undo日志的主要区别</h5><ul><li>恢复的目的不一样</li></ul><ul><li><p>提交记录&lt;Commit T&gt;写入日志的时间不一样</p><ul><li><p>undo日志：在事务 T 的所有数据库磁盘修改操作(Output)结束后才能在日志中写入提交记录&lt;Commit T&gt;</p></li><li><p>redo日志：在提交记录&lt;Commit T&gt;被写入磁盘后才能将事务T更新后的值写入数据库的磁盘中</p></li></ul></li><li><p>在更新记录&lt;T, X, V&gt;中保存的值V不一样</p></li></ul><h5 id="（5）redo日志与undo日志的不足"><a href="#（5）redo日志与undo日志的不足" class="headerlink" title="（5）redo日志与undo日志的不足"></a>（5）redo日志与undo日志的不足</h5><ul><li>Undo 日志要求数据在事务结束后立即写到磁盘，可能增加需要执行磁盘 I&#x2F;O 的次数</li><li>Redo 日志要求事务提交和日志记录刷新之前将所有修改过的数据保留在内存缓冲区中，可能增加事务需要的平均缓冲区的数量</li><li>如果被访问的数据对象 X 不是完整的磁盘块，那么在 undo 日志与 redo 日志之间可能产生相互矛盾的请求</li></ul><h5 id="（6）undo-x2F-redo日志"><a href="#（6）undo-x2F-redo日志" class="headerlink" title="（6）undo&#x2F;redo日志"></a>（6）undo&#x2F;redo日志</h5><ul><li><p>undo&#x2F;redo 日志的记录格式</p><ul><li>与 undo 日志或 redo 日志的格式基本一样，区别在于更新记录的格式：&lt;T,X,v,w&gt;<ul><li>不仅记录更新前的值 v ，同时也要记录更新后的新值 w</li><li>因此该种类型的日志既能用于未结束事务的撤消(undo)，也能用于已提交事务的重做 (redo)</li></ul></li></ul></li><li><p>undo&#x2F;redo 日志的记载规则</p><ul><li>$UR_1$：在由于某个事务 T 所做的改变而修改磁盘上的数据库元素 X 之前，更新记录 &lt;T, X, v, w&gt; 必须出现在磁盘上。<ul><li>其中， v 是 X 被更新前的值， w 是 X 被更新后的值</li></ul></li></ul></li><li><p>使用undo&#x2F;redo日志的故障恢复过程</p><ul><li><p>根据&lt;Commit T&gt;是否已经出现在磁盘中来决定事务T是否已经被提交</p></li><li><p>具体的恢复过程如下：</p><ul><li><p>按照从后往前的顺序，撤消(undo)所有未提交的事务</p></li><li><p>按照从前往后的顺序，重做(redo)所有已提交的事务</p></li></ul></li></ul></li><li><p>为了确保在日志中写入&lt;Commit T&gt;记录的事务 T 确实被提交，为undo&#x2F;redo日志新增加了一条记载规则：</p><ul><li>$UR_2$：在每一条&lt;Commit T&gt; 后面必须紧跟一条Flush Log 操作</li></ul></li><li><p>在undo&#x2F;redo日志中插入检查点</p><ul><li><p>写入日志记录&lt;Start CKPT(T1,**…**,Tk)&gt;，并刷新日志</p><ul><li>其中：T1,<strong>…</strong>,Tk是当前所有活跃事务的标识符</li></ul></li><li><p>将所有被修改过的缓冲区写到数据库的磁盘中去</p></li><li><p>写入日志记录&lt;End CKPT&gt;并刷新日志</p></li></ul></li></ul><h4 id="3-事务的撤消与重做"><a href="#3-事务的撤消与重做" class="headerlink" title="3. 事务的撤消与重做"></a>3. 事务的撤消与重做</h4><h5 id="（1）事务的撤消（undo）"><a href="#（1）事务的撤消（undo）" class="headerlink" title="（1）事务的撤消（undo）"></a>（1）事务的撤消（undo）</h5><ul><li><p>反向扫描日志文件，查找应该撤消的事务</p></li><li><p>查找这些事务的更新操作</p></li><li><p>对更新操作做逆操作</p><ul><li><p>插入操作：删除被插入的元组</p></li><li><p>删除操作：将被删除的元组重新插入</p></li><li><p>修改操作：用修改前的值替代修改后的值</p></li></ul></li><li><p>如此反向扫描直到日志文件的头部</p></li></ul><h5 id="（2）事务的重做（redo）"><a href="#（2）事务的重做（redo）" class="headerlink" title="（2）事务的重做（redo）"></a>（2）事务的重做（redo）</h5><ul><li>正向扫描日志文件，查找应该重做的事务</li><li>查找这些事务的更新操作</li><li>对更新操作作重做处理<ul><li>插入操作：重新插入新元组</li><li>删除操作：重新删除旧的元组</li><li>修改操作：用修改后的值替代修改前的值</li></ul></li><li>如此正向扫描直到日志文件的尾部</li></ul><h3 id="（四）恢复策略"><a href="#（四）恢复策略" class="headerlink" title="（四）恢复策略"></a>（四）恢复策略</h3><h4 id="1-小型故障的恢复"><a href="#1-小型故障的恢复" class="headerlink" title="1. 小型故障的恢复"></a>1. 小型故障的恢复</h4><ul><li>利用未结束事务的 undo 操作进行恢复</li></ul><h4 id="2-中型故障的恢复"><a href="#2-中型故障的恢复" class="headerlink" title="2. 中型故障的恢复"></a>2. 中型故障的恢复</h4><ul><li>有两类事务需要恢复<ul><li>非正常中止的事务<ul><li>执行 undo 操作</li></ul></li><li>已完成提交的事务<ul><li>其更新操作的修改结果还留在内存缓冲区中，尚未来得及写入磁盘，由于故障使内存缓冲区中的数据被丢失</li><li>执行 redo 操作</li></ul></li></ul></li></ul><h4 id="3-大型故障的恢复"><a href="#3-大型故障的恢复" class="headerlink" title="3. 大型故障的恢复"></a>3. 大型故障的恢复</h4><ul><li>先利用后备副本进行数据库恢复，再利用日志进行数据库的恢复。具体步骤如下<ul><li>将后备副本中的数据拷贝到数据库中</li><li>检查日志文件：确定哪些事务已经执行结束，哪些尚未结束</li><li>按照日志的记载顺序<ul><li>逆向：对尚未结束的事务作撤消处理 (undo)</li><li>正向：对已经结束的事务作重做处理 (redo)</li></ul></li></ul></li></ul><h3 id="（五）数据库镜像"><a href="#（五）数据库镜像" class="headerlink" title="（五）数据库镜像"></a>（五）数据库镜像</h3><ul><li><p>将整个数据库中的数据（或主要数据）实时复制到另一个磁盘中</p><ul><li><p>也称为<strong>磁盘镜像</strong></p></li><li><p>系统自动保证主数据库服务器中的数据与数据库镜像中的数据的一致性</p></li><li><p>在数据库中的数据遭受破坏后，可以利用数据库镜像中的数据进行修补</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库概论四：数据库的安全性与完整性保护</title>
    <link href="/2022/11/05/database_note_4/"/>
    <url>/2022/11/05/database_note_4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据库的安全性"><a href="#一、数据库的安全性" class="headerlink" title="一、数据库的安全性"></a>一、数据库的安全性</h2><h3 id="（一）数据库的安全与安全数据库"><a href="#（一）数据库的安全与安全数据库" class="headerlink" title="（一）数据库的安全与安全数据库"></a>（一）数据库的安全与安全数据库</h3><h4 id="数据库的安全"><a href="#数据库的安全" class="headerlink" title="数据库的安全"></a>数据库的安全</h4><ul><li><p>防止非法使用数据库。即要求数据库的用户：</p><ul><li><p>通过规定的访问途径</p></li><li><p>按照规定的访问规则（规范）</p></li></ul><p>来访问数据库中的数据，并接受来自<strong>DBMS</strong>的各种检查</p></li></ul><h3 id="（二）数据库安全的基本概念与内容"><a href="#（二）数据库安全的基本概念与内容" class="headerlink" title="（二）数据库安全的基本概念与内容"></a>（二）数据库安全的基本概念与内容</h3><h4 id="1-可信计算基TCB"><a href="#1-可信计算基TCB" class="headerlink" title="1. 可信计算基TCB"></a>1. 可信计算基<strong>TCB</strong></h4><ul><li><p>它是为实现数据库安全所采用的所有实施策略与机制的集合</p></li><li><p>它是实施、检查、监督数据库安全的机构</p></li></ul><h4 id="2-主体、客体与主客体分离"><a href="#2-主体、客体与主客体分离" class="headerlink" title="2. 主体、客体与主客体分离"></a>2. 主体、客体与主客体分离</h4><ul><li><p>客体</p><ul><li><p>数据库中的数据及其载体</p></li><li><p>如：表、视图、快照、存储过程、数据文件等</p></li></ul></li><li><p>主体</p><ul><li>数据库中数据的访问者</li></ul></li><li><p>与数据库安全有关的所有实体都可以被抽象为主体或客体。由所有主体构成的主体集合与由所有客体构成的客体集合之间存在着一种单向访问关系。</p></li><li><p>数据库安全就是研究有关实体的主&#x2F;客体划分以及主&#x2F;客体之间的访问关系的控制</p></li></ul><h4 id="3-身份标识与鉴别"><a href="#3-身份标识与鉴别" class="headerlink" title="3. 身份标识与鉴别"></a>3. 身份标识与鉴别</h4><ul><li><p>在数据库安全中，主体访问客体时需进行一定的安全控制与检查，目前存在三种控制方式：</p><ul><li>身份标识与鉴别</li><li>自主访问控制</li><li>强制访问控制</li></ul></li><li><p>其中身份标识与鉴别是系统提供的最外层安全保护措施</p></li><li><p>每个主体必须有一个标志自己身份的标识符（以区别不同的主体）以及一个用以验证其身份的访问口令。当主体访问客体时，<strong>TCB</strong> 将对主体所提交的身份标识符和口令进行鉴别，以阻止非法访问</p></li><li><p>常用的控制措施</p><ul><li><p>登录控制</p><ul><li>对用户标识符和口令的鉴别</li><li>限制重复性登录失败次数</li><li>保证登录的可信路径（本地或远程）</li><li>限制在一天当中允许访问的时间</li></ul></li><li><p>口令字选取</p><ul><li>控制用户口令字选取，如：最小长度，组合，历史等</li><li>某些口令可由系统生成再分配给用户</li><li>强制实施口令字有效期机制</li></ul></li><li><p>对鉴别数据的保护</p><ul><li>输入口令字时不许回显</li><li>避免未授权的访问与修改</li><li>防止重播攻击</li><li>防止伪造或拷贝</li><li>防止重用，如：只允许单次使用的口令字</li><li>提供口令字修改的可信路径</li></ul></li><li><p>会话连接挂起</p><ul><li>在用户停止操作一段时间后挂起</li><li>根据用户要求挂起</li><li>在用户停止操作一段时间后终止</li></ul></li><li><p>用户帐号和属性文件</p><ul><li>控制对用户帐号的生成、删除、激活或停用</li><li>定义用户属性文件中所包含的安全属性</li><li>控制对用户属性文件的修改</li></ul></li></ul></li></ul><h4 id="4-自主访问控制（DAC）"><a href="#4-自主访问控制（DAC）" class="headerlink" title="4. 自主访问控制（DAC）"></a>4. 自主访问控制（<strong>DAC</strong>）</h4><ul><li><p>是一种基于存取矩阵的安全控制模型</p></li><li><p>此模型由主体、客体和存&#x2F;取操作三部分内容构成了一个矩阵</p></li><li><p>基于存取矩阵的自主访问控制功能</p><ul><li><p>安全政策范围验证</p><ul><li>主体、客体以及操作</li></ul></li><li><p>控制主体访问客体的规则验证</p><ul><li><p>主体按存取矩阵模型的要求访问客体</p></li><li><p>凡不符合存取矩阵要求的访问均属非法访问</p></li></ul></li><li><p>超越<strong>DAC</strong>的特权验证</p><ul><li>如数据库管理员、客体的属主等</li></ul></li></ul></li><li><p>对<strong>DAC</strong>属性的控制</p><ul><li>改变客体的许可权限</li><li>对新建客体的缺省保护</li><li>改变客体的属主</li><li>改变用户组的隶属关系</li></ul></li><li><p><strong>DAC</strong>的特点</p><ul><li><p>存取矩阵中的元素是可以随意改变的</p></li><li><p>主体可以通过授权（ Grant ）&#x2F; 回收（ Revoke ）操作变更某些操作权限</p></li><li><p>适合于单机方式下的访问控制</p></li></ul></li></ul><h4 id="5-强制访问控制（MAC）"><a href="#5-强制访问控制（MAC）" class="headerlink" title="5. 强制访问控制（MAC）"></a>5. 强制访问控制（<strong>MAC</strong>）</h4><ul><li><p>是主体访问客体的一种强制性的安全控制方式，主要用于网络环境，对网络中的数据库安全实体作统一的、强制性的访问管理</p></li><li><p>主 &#x2F; 客体标记（ label ）</p><ul><li>安全级别标记（ label of security level）<ul><li>规定了主客体的安全级别</li></ul></li><li>安全范围标记（ label of security category）<ul><li>规定了主体可以访问的范围（客体所处的范围）</li></ul></li></ul></li><li><p>在主体访问客体的过程中，主体与客体的标记必须满足系统所采用的强制访问控制策略的要求，否则将被视为非法访问</p></li><li><p>强制访问控制的实施机制：<strong>Bell-Lapadula</strong>模型</p><ul><li><p>每个标记由一个整数的分层密级和一个非分层范畴的集合构成。当主体访问客体时必须满足以下条件：</p><ul><li><p>（下读）仅当主体的分层密级大于或等于客体的分层密级，且主体的非分层范畴集合包含或等于客体的非分层范畴集合时，主体才能读客体</p></li><li><p>（上写）仅当主体的分层密级小于或等于客体的分层密级，且主体的非分层范畴集合被包含或等于客体的非分层范畴集合时，主体才能写客体</p></li></ul></li><li><p>强制访问控制中的主、客体标记由专门的安全管理员设置，任何主体均无权设置与授权，它体现了在网上对数据库安全的强制性与统一性</p></li></ul></li><li><p>强制性的访问控制措施</p><ul><li><p>安全政策范围验证</p><ul><li>主体、客体以及操作</li></ul></li><li><p>验证控制访问和信息流动的规则</p></li><li><p>验证可超越<strong>MAC</strong>特权</p></li></ul></li><li><p>对<strong>MAC</strong>属性的控制</p><ul><li>改变客体标记</li><li>对新建客体的缺省标记</li><li>改变主体安全属性</li></ul></li></ul><h4 id="6-数据完整性"><a href="#6-数据完整性" class="headerlink" title="6. 数据完整性"></a>6. 数据完整性</h4><ul><li><p>防止非法使用插入（<strong>insert</strong>）、删除（<strong>delete</strong>）、修改（<strong>update</strong>）等影响数据完整性的操作</p></li><li><p>控制手段</p><ul><li><p>对存储数据错误的检测</p></li><li><p>事务回卷功能</p></li></ul></li><li><p>常用的控制手段：三类数据完整性</p><ul><li>实体完整性</li><li>关联完整性</li><li>用户定义完整性约束</li></ul></li></ul><h4 id="7-隐蔽通道"><a href="#7-隐蔽通道" class="headerlink" title="7. 隐蔽通道"></a>7. 隐蔽通道</h4><ul><li><p>在主体对客体的访问过程中，可通过自主及强制访问控制措施来提供安全保护</p></li><li><p>公开通道</p><ul><li>正规的、接受<strong>TCB</strong>的（自主&#x2F;强制）访问控制检查的访问通道</li></ul></li><li><p>隐蔽通道</p><ul><li>非正规的、不受<strong>TCB</strong> 控制的访问通道</li></ul></li><li><p>为了真正保证数据的安全性，就必须分析、发现隐蔽通道，防止隐蔽通道的产生</p></li></ul><h4 id="8-数据库安全的形式化模型"><a href="#8-数据库安全的形式化模型" class="headerlink" title="8. 数据库安全的形式化模型"></a>8. 数据库安全的形式化模型</h4><ul><li><p>用数学形式对数据安全模型的安全策略作形式化描述、验证与证明，形成严格的形式化体系</p></li><li><p>建立一个数据库安全的形式化模型，有利于发现并填补安全漏洞，防止隐蔽通道，并为数据安全的进一步研究提供理论基础</p></li></ul><h4 id="9-审计"><a href="#9-审计" class="headerlink" title="9. 审计"></a>9. 审计</h4><ul><li><p>跟踪记录用户对数据的访问操作：</p><ul><li><p>访问时间 &#x2F; 访问内容 &#x2F; 用户名 &#x2F; 终端名 &#x2F; 操作类型 &#x2F; 操作结果</p></li><li><p>并可根据审计结果给出报警信息</p></li></ul></li><li><p>由于执行审计操作需要额外的时间和空间开销，因此在<strong>DBMS</strong>中，<strong>审计</strong>通常是一个可选择的安全保护手段，主要用于安全性要求较高的部门</p></li><li><p>与审计有关的保护措施有：</p><ul><li><p>审计事件控制</p><ul><li>对可审计事件和需记录信息的说明</li><li>对需审计事件选择的控制</li><li>对单个身份审计</li></ul></li><li><p>入侵检测和应对</p><ul><li>生成报警信息，并对即将发生的安全违规行为采取应对措施</li><li>定义用于指示潜在或即将发生的安全违规行为的那些规则、事件、事件序列或系统使用模式</li></ul></li><li><p>审计记录的保护</p><ul><li><p>避免数据丢失，如：审计记录饱和、操作中断等</p></li><li><p>避免未授权的修改 &#x2F; 访问</p></li></ul></li><li><p>审计记录的分析 &#x2F; 查阅</p><ul><li>提供相应的分析 &#x2F; 查阅工具</li></ul></li></ul></li></ul><h4 id="10-访问监控器"><a href="#10-访问监控器" class="headerlink" title="10. 访问监控器"></a>10. 访问监控器</h4><ul><li><p>上述的安全策略须有一个网络中的实体来完成，即访问监控器</p><ul><li>访问监控器是一个独立的（既非主体，亦非客体）、最小的、抗篡改的、自主机构，用来监控主体和客体之间的授权访问关系</li></ul></li><li><p><strong>TCB</strong>是一个抽象的功能 &#x2F; 策略集合，而访问监控器则是一个客观存在的实体，是<strong>TCB</strong>在网络中的实现</p></li></ul><h3 id="（三）数据库的安全标准"><a href="#（三）数据库的安全标准" class="headerlink" title="（三）数据库的安全标准"></a>（三）数据库的安全标准</h3><ul><li><p>计算机信息系统安全保护等级划分准则（<strong>GB 17859-1999</strong>）</p><table><thead><tr><th align="center">GB 17859-1999分级</th><th align="center">TCSEC分级</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">D</td></tr><tr><td align="center">第1级：自主安全保护级</td><td align="center">C1</td></tr><tr><td align="center">第2级：系统审计保护级</td><td align="center">C2</td></tr><tr><td align="center">第3级：安全标记保护级</td><td align="center">B1</td></tr><tr><td align="center">第4级：结构化保护级</td><td align="center">B2</td></tr><tr><td align="center">第5级：访问验证保护级</td><td align="center">B3</td></tr><tr><td align="center">-</td><td align="center">A</td></tr></tbody></table></li></ul><h3 id="（四）SQL对数据库安全的支持"><a href="#（四）SQL对数据库安全的支持" class="headerlink" title="（四）SQL对数据库安全的支持"></a>（四）<strong>SQL</strong>对数据库安全的支持</h3><ul><li><p>在 SQL’92 中提供了 C1 级数据库安全的支持，它们是：</p><ul><li><p>主体、客体及主&#x2F;客体分离</p></li><li><p>身份标识与鉴别</p></li><li><p>数据完整性</p></li><li><p>自主访问控制与授权功能</p><ul><li><p>SQL 中的自主访问控制是通过（用户，操作对象，操作权限）这样的三元组来定义用户对于数据的访问权限的，并可通过授权（ Grant ）和回收（ Revoke ）语句来改变用户的访问权限</p></li><li><p>操作权限</p><ul><li>SELECT权、INSERT权、DELETE权、UPDATE权、REFERENCE权、EXECUTE权、USAGE权</li></ul></li><li><p>操作对象</p><ul><li><p>表，视图</p></li><li><p>属性</p></li><li><p>域（<strong>type</strong>），<strong>UDT</strong>（用户定义数据类型）</p></li><li><p>存储过程 &#x2F; 函数，触发器</p></li></ul></li><li><p>用户</p><ul><li>数据库用户</li></ul></li><li><p>授权语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>操作权限列表<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>操作对象<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户名列表<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br></code></pre></td></tr></table></figure></li><li><p>回收语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>操作权限列表<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>操作对象<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>用户名列表<span class="hljs-operator">&gt;</span> [RESTRICT <span class="hljs-operator">|</span> CASCADE]<br></code></pre></td></tr></table></figure><ul><li><p>CASCADE：连锁回收</p></li><li><p>RESTRICT：在不存在连锁回收问题时才能回收权限，否则拒绝回收</p></li></ul></li></ul></li></ul></li></ul><h2 id="二、数据库的完整性"><a href="#二、数据库的完整性" class="headerlink" title="二、数据库的完整性"></a>二、数据库的完整性</h2><h3 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h3><h4 id="1-数据库的完整性"><a href="#1-数据库的完整性" class="headerlink" title="1. 数据库的完整性"></a>1. 数据库的完整性</h4><ul><li><p>指数据库中数据的正确性和一致性，包括：</p><ul><li><p>正确性：数据的有效性、有意义</p></li><li><p>一致性：在多用户（多程序）并发访问数据库的情况下，保证对数据的更新不会出现与实际不一致的情况</p></li></ul></li><li><p>我们一方面要避免在数据库中出现错误的数据，即防止数据的完整性受到破坏。同时，如果因为某些不可抗拒的原因而导致数据库中的数据被破坏，也要能够及时发现并采取一定的措施将数据库中的数据恢复到正确的状态下去</p></li></ul><h4 id="2-完整性保护"><a href="#2-完整性保护" class="headerlink" title="2. 完整性保护"></a>2. 完整性保护</h4><ul><li><p>对数据库中数据的正确性和一致性的维护，包括：</p><ul><li><p>在执行更新操作时，检查是否违反完整性约束条件，并且在证明其无效后作出适当的反应</p></li><li><p>防止有存取权的合法用户的误操作</p></li></ul></li></ul><h4 id="3-完整性保护的目的"><a href="#3-完整性保护的目的" class="headerlink" title="3. 完整性保护的目的"></a>3. 完整性保护的目的</h4><ul><li><p>及时发现错误</p></li><li><p>能够采取措施防止错误的进一步蔓延</p></li><li><p>最终将数据库恢复到正确状态</p></li></ul><h4 id="4-完整性保护的实现措施"><a href="#4-完整性保护的实现措施" class="headerlink" title="4. 完整性保护的实现措施"></a>4. 完整性保护的实现措施</h4><ul><li>完整性约束条件的定义及检查</li><li>触发器</li><li>并发控制技术</li></ul><h3 id="（二）数据库完整性保护的功能"><a href="#（二）数据库完整性保护的功能" class="headerlink" title="（二）数据库完整性保护的功能"></a>（二）数据库完整性保护的功能</h3><h4 id="三个基本功能"><a href="#三个基本功能" class="headerlink" title="三个基本功能"></a>三个基本功能</h4><ul><li><p>设置功能</p><ul><li>系统及用户对数据库完整性的基本要求</li></ul></li><li><p>检查功能</p><ul><li>有能力检查数据库中的数据是否有违反约束条件的现象出现</li></ul></li><li><p>处理功能</p><ul><li>出现违反约束条件时，有及时处理的能力</li></ul></li></ul><h3 id="（三）完整性规则的三个内容"><a href="#（三）完整性规则的三个内容" class="headerlink" title="（三）完整性规则的三个内容"></a>（三）完整性规则的三个内容</h3><h4 id="在关系数据库系统中提供了下述三类数据完整性约束："><a href="#在关系数据库系统中提供了下述三类数据完整性约束：" class="headerlink" title="在关系数据库系统中提供了下述三类数据完整性约束："></a>在关系数据库系统中提供了下述三类数据完整性约束：</h4><ul><li><p>实体完整性规则</p><ul><li>在一个基表的<strong>主关键字</strong>（主码）中，其属性的取值不能为空值</li></ul></li><li><p>参照完整性规则</p><ul><li><p>若关系 R 中有属性集 F 与另一个关系 S 的主关键字 K<sub>s</sub> 相对应（即具有相同的语义和取值范围），则称关系 R 引用关系 S 中的元组</p><ul><li>这样的属性集 F 被称为关系 R 的外关键字（关系 R 和关系 S 可以是同一个关系）</li></ul></li><li><p>参照完整性规则要求</p><ul><li>关系 R 中的每个元组在外关键字 F 上的值或者是空值（ NULL ），或必须引用在关系 S 中存在的元组，即不能引用不存在的实体</li></ul></li></ul></li><li><p>用户定义的完整性规则</p><ul><li>由用户来定义的数据完整性要求</li></ul></li></ul><h3 id="（四）完整性约束的设置、检查与处理"><a href="#（四）完整性约束的设置、检查与处理" class="headerlink" title="（四）完整性约束的设置、检查与处理"></a>（四）完整性约束的设置、检查与处理</h3><h4 id="1-一条完整性约束规则一般有三个组成部分"><a href="#1-一条完整性约束规则一般有三个组成部分" class="headerlink" title="1. 一条完整性约束规则一般有三个组成部分"></a>1. 一条完整性约束规则一般有三个组成部分</h4><ul><li><p>完整性约束条件的设置</p></li><li><p>完整性约束条件的检查</p><ul><li>在<strong>DBMS</strong>内部设置专门的软件检查模块</li></ul></li><li><p>完整性约束条件的处理</p><ul><li>在用户的操作会破坏数据的完整性（即违反完整性约束条件的要求）时，系统将：<ul><li>拒绝执行，并报警或报错；</li><li>调用相应的函数（例程）进行处理，如：<ul><li>在外键定义子句中给出的处理方法</li><li>在触发器中给出的处理过程</li></ul></li></ul></li></ul></li></ul><h4 id="2-完整性约束条件设置"><a href="#2-完整性约束条件设置" class="headerlink" title="2. 完整性约束条件设置"></a>2. 完整性约束条件设置</h4><ul><li><p>属性级的约束（域约束）</p><ul><li>数据类型的约束，非空值约束，取值范围的约束</li></ul></li><li><p>元组级的约束（表约束）</p><ul><li><p>主码定义，候选码（唯一键）定义</p></li><li><p>外码定义</p></li><li><p>基于元组的检查子句：属性间关系的定义</p></li></ul></li><li><p>全局约束（断言<strong>assertion</strong>）</p><ul><li>单个关系中涉及到统计操作的约束条件</li><li>多个关系之间复杂的约束条件</li></ul></li></ul><h4 id="3-对约束命名"><a href="#3-对约束命名" class="headerlink" title="3. 对约束命名"></a>3. 对约束命名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>约束名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>完整性约束定义子句<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-创建基表命令（CREATE-TABLE）"><a href="#4-创建基表命令（CREATE-TABLE）" class="headerlink" title="4. 创建基表命令（CREATE TABLE）"></a>4. 创建基表命令（<strong>CREATE TABLE</strong>）</h4><ul><li><p>需要定义的内容</p><ul><li>模式名 &amp; 表名</li></ul></li><li><p>属性的定义</p><ul><li><p>属性名 &amp; 数据类型</p></li><li><p>属性的缺省值定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DEFAULT</span> &#123;default_constant <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>属性级的数据约束定义</p></li></ul></li><li><p>表级的数据约束定义</p></li></ul><h4 id="5-属性级的约束"><a href="#5-属性级的约束" class="headerlink" title="5. 属性级的约束"></a>5. 属性级的约束</h4><ul><li>数据类型的约束，取值范围的约束，非空值约束</li><li>基于单个属性的取值约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123;<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br>[<span class="hljs-keyword">CONSTRAINT</span> constraint_name]<br><span class="hljs-keyword">UNIQUE</span><br><span class="hljs-operator">|</span><span class="hljs-keyword">PRIMARY</span> KEY<br><span class="hljs-operator">|</span><span class="hljs-keyword">CHECK</span> (search_condition)<br><span class="hljs-operator">|</span><span class="hljs-keyword">REFERENCES</span> table_name [( column_name )]<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-operator">|</span> RESTRICT <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>]<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-operator">|</span> RESTRICT <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>]<br></code></pre></td></tr></table></figure><ul><li>基于多个属性的取值约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">[<span class="hljs-keyword">CONSTRAINT</span> constraint_name]<br>&#123;<span class="hljs-keyword">UNIQUE</span> (colname &#123; , colname ... &#125;)<br><span class="hljs-operator">|</span><span class="hljs-keyword">PRIMARY</span> KEY (colname &#123; , colname ... &#125;)<br><span class="hljs-operator">|</span><span class="hljs-keyword">CHECK</span> (search_condition)<br><span class="hljs-operator">|</span><span class="hljs-keyword">FOREIGN</span> KEY (colname &#123; , colname ... &#125;)<br><span class="hljs-keyword">REFERENCES</span> table_name [(colname &#123; , colname ...&#125;)<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-operator">|</span> RESTRICT <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>]<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-operator">|</span> RESTRICT <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>]&#125;<br></code></pre></td></tr></table></figure><h4 id="6-在定义属性级的数据约束时需要考虑的内容"><a href="#6-在定义属性级的数据约束时需要考虑的内容" class="headerlink" title="6. 在定义属性级的数据约束时需要考虑的内容"></a>6. 在定义属性级的数据约束时需要考虑的内容</h4><ul><li><p>NOT NULL vs. DEFAULT NULL</p></li><li><p>Constraint name</p><ul><li>对某个数据约束条件进行命名（ 可选项）</li><li>以利于以后使用 ALTER TABLE 命令来修改表中的数据约束定义</li></ul></li><li><p>UNIQUE vs. NOT NULL</p><ul><li>UNIQUE 属性可以取空值</li><li>候选键（ candidate key）：UNIQUE + NOT NULL</li></ul></li><li><p>PRIMARY KEY vs. NOT NULL</p></li><li><p>REFERENCES</p><ul><li>FOREIGN KEY （外键） vs. PRIMARY KEY （主键）</li><li>外键上的取值约束及其一致性的保证措施<ul><li>CASCADE | RESTRICT | SET NULL</li></ul></li></ul></li><li><p>CHECK</p></li></ul><h4 id="7-元组级的约束"><a href="#7-元组级的约束" class="headerlink" title="7. 元组级的约束"></a>7. 元组级的约束</h4><ul><li><p>主码定义： PRIMARY KEY ( <column list> )</p></li><li><p>唯一键定义： UNIQUE ( <column list> )</p></li><li><p>外码定义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FOREIGN</span> KEY ( <span class="hljs-operator">&lt;</span>fk<span class="hljs-operator">-</span><span class="hljs-keyword">column</span> list<span class="hljs-operator">&gt;</span> )<br><span class="hljs-keyword">REFERENCES</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span><span class="hljs-operator">-</span>name<span class="hljs-operator">&gt;</span> ( <span class="hljs-operator">&lt;</span>pk<span class="hljs-operator">-</span><span class="hljs-keyword">column</span><span class="hljs-operator">-</span>list<span class="hljs-operator">&gt;</span> )<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> [RESTRICT CASCADE <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>]]<br>[<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> [RESTRICT CASCADE <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>]]<br></code></pre></td></tr></table></figure></li><li><p>属性间关系的定义：CHECK ( <condition> )</p></li></ul><h3 id="（五）触发器"><a href="#（五）触发器" class="headerlink" title="（五）触发器"></a>（五）触发器</h3><h4 id="1-触发器"><a href="#1-触发器" class="headerlink" title="1. 触发器"></a>1. 触发器</h4><ul><li><p>在数据库系统中，一个事件的发生会导致另外一些事件的发生，这样的功能被称为触发器</p></li><li><p>触发器的功能：某个事件的发生会导致另外一些事件的执行，以消除前一个事件对数据完整性所起的影响</p></li><li><p>触发器最初是用于数据的完整性保护，但现在已经远远超出了此范围，也被应用于其它的目的，如：</p><ul><li>数据的安全性保护</li><li>用户的应用逻辑处理</li><li>数据库系统的主动功能</li></ul></li></ul><h4 id="2-触发器的组成"><a href="#2-触发器的组成" class="headerlink" title="2. 触发器的组成"></a>2. 触发器的组成</h4><ul><li><p>触发事件（由用户定义）</p><ul><li><p>通常为某个完整性约束条件的否定或某种数据操纵事件</p></li><li><p>如：用户登录，数据的增、删、改等</p></li></ul></li><li><p>结果事件（由用户定义）</p><ul><li><p>当触发事件发生时，用以消除触发事件所引起的负面影响的程序</p></li><li><p>通常是一组由用户书写的<strong>SQL</strong>命令</p></li></ul></li><li><p>触发过程</p><ul><li>当<strong>DBMS</strong>检测到触发事件的发生时，自动调用并执行结果事件的过程</li></ul></li></ul><h4 id="3-触发器的定义命令"><a href="#3-触发器的定义命令" class="headerlink" title="3. 触发器的定义命令"></a>3. 触发器的定义命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name &#123; BEFORE <span class="hljs-operator">|</span> AFTER &#125;<br>&#123;<span class="hljs-keyword">INSERT</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DELETE</span><br><span class="hljs-operator">|</span><span class="hljs-keyword">UPDATE</span> [ <span class="hljs-keyword">OF</span> colname &#123; , colname ... &#125;]&#125;<br><span class="hljs-keyword">ON</span> table_name<br>[<span class="hljs-keyword">REFERENCING</span> corr_name_def &#123; , ......&#125;]<br>[ <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> STATEMENT]<br>[ <span class="hljs-keyword">WHEN</span> (search_condition)]<br>&#123;statement<br><span class="hljs-operator">|</span><span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">ATOMIC</span> statement; &#123;statement; ...&#125; <span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><h4 id="4-触发器的删除命令"><a href="#4-触发器的删除命令" class="headerlink" title="4. 触发器的删除命令"></a>4. 触发器的删除命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> trigger_name;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库概论三：关系数据库系统</title>
    <link href="/2022/10/22/database_note_3/"/>
    <url>/2022/10/22/database_note_3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、关系数据库系统的优点"><a href="#一、关系数据库系统的优点" class="headerlink" title="一、关系数据库系统的优点"></a>一、关系数据库系统的优点</h2><h4 id="1-数据结构简单"><a href="#1-数据结构简单" class="headerlink" title="1. 数据结构简单"></a>1. 数据结构简单</h4><ul><li>关系数据库系统中的数据结构：<strong>二维表</strong></li></ul><h4 id="2-用户使用方便"><a href="#2-用户使用方便" class="headerlink" title="2. 用户使用方便"></a>2. 用户使用方便</h4><ul><li>不涉及系统的内部物理结构</li><li>非过程性数据子语言</li></ul><h4 id="3-功能强"><a href="#3-功能强" class="headerlink" title="3. 功能强"></a>3. 功能强</h4><ul><li>模型的表达能力强，具有一定的模型修改功能</li><li>可方便地修改数据间的联系</li><li>可灵活选择数据存取路径</li><li>高级的数据操纵语言</li></ul><h4 id="4-数据独立性高"><a href="#4-数据独立性高" class="headerlink" title="4. 数据独立性高"></a>4. 数据独立性高</h4><ul><li>数据的逻辑结构不涉及物理因素</li><li>操作的非过程性</li></ul><h4 id="5-理论基础深"><a href="#5-理论基础深" class="headerlink" title="5. 理论基础深"></a>5. 理论基础深</h4><ul><li>关系数据库系统一般建立在逻辑与代数基础上</li></ul><h4 id="6-可移植性好"><a href="#6-可移植性好" class="headerlink" title="6. 可移植性好"></a>6. 可移植性好</h4><ul><li>能同时适应多个机种与多个操作系统</li></ul><h4 id="7-标准化程度高"><a href="#7-标准化程度高" class="headerlink" title="7. 标准化程度高"></a>7. 标准化程度高</h4><ul><li>SQL’92被认为是典型的关系数据库系统语言。</li></ul><h4 id="8-分布式功能"><a href="#8-分布式功能" class="headerlink" title="8. 分布式功能"></a>8. 分布式功能</h4><ul><li>数据库远程访问、客户-服务器方式、浏览器-服务器方式</li></ul><h4 id="9-开放性"><a href="#9-开放性" class="headerlink" title="9. 开放性"></a>9. 开放性</h4><ul><li>通过提供各种网络环境下的数据访问接口来实现系统的开放性</li></ul><h2 id="二、关系数据库系统的衡量准则"><a href="#二、关系数据库系统的衡量准则" class="headerlink" title="二、关系数据库系统的衡量准则"></a>二、关系数据库系统的衡量准则</h2><h3 id="（一）六条准则（1974年IFIP会议）"><a href="#（一）六条准则（1974年IFIP会议）" class="headerlink" title="（一）六条准则（1974年IFIP会议）"></a>（一）六条准则（1974年IFIP会议）</h3><h4 id="1-提供高度的数据独立性"><a href="#1-提供高度的数据独立性" class="headerlink" title="1. 提供高度的数据独立性"></a>1. 提供高度的数据独立性</h4><h4 id="2-提供严格的数据视图"><a href="#2-提供严格的数据视图" class="headerlink" title="2. 提供严格的数据视图"></a>2. 提供严格的数据视图</h4><h4 id="3-减轻-DBA-的工作"><a href="#3-减轻-DBA-的工作" class="headerlink" title="3. 减轻 DBA 的工作"></a>3. 减轻 DBA 的工作</h4><h4 id="4-建立理论基础"><a href="#4-建立理论基础" class="headerlink" title="4. 建立理论基础"></a>4. 建立理论基础</h4><h4 id="5-事务管理与文件管理相结合"><a href="#5-事务管理与文件管理相结合" class="headerlink" title="5. 事务管理与文件管理相结合"></a>5. 事务管理与文件管理相结合</h4><ul><li>为商业及其它行业的服务作准备</li></ul><h4 id="6-操作对象是记录集合，而不是单个记录"><a href="#6-操作对象是记录集合，而不是单个记录" class="headerlink" title="6. 操作对象是记录集合，而不是单个记录"></a>6. 操作对象是记录集合，而不是单个记录</h4><h3 id="（二）完全关系型的12条严格标准（1985年）"><a href="#（二）完全关系型的12条严格标准（1985年）" class="headerlink" title="（二）完全关系型的12条严格标准（1985年）"></a>（二）完全关系型的12条严格标准（1985年）</h3><h4 id="1-信息准则"><a href="#1-信息准则" class="headerlink" title="1. 信息准则"></a>1. 信息准则</h4><ul><li>关系数据库的所有信息都应能在逻辑一级唯一地用<strong>表</strong>中的值显式表示<ul><li>用表中的<strong>元组</strong>或元组中的<strong>属性值</strong>来表示</li></ul></li><li>数据库的结构描述信息也应在逻辑上组织成关系形式</li></ul><h4 id="2-确保访问准则"><a href="#2-确保访问准则" class="headerlink" title="2. 确保访问准则"></a>2. 确保访问准则</h4><ul><li>应能保证用逻辑方式依靠表名、关键字值与列名的组合来访问数据库中每一个原子数据</li></ul><h4 id="3-空值的关系处理准则"><a href="#3-空值的关系处理准则" class="headerlink" title="3. 空值的关系处理准则"></a>3. 空值的关系处理准则</h4><ul><li>空值（null value）<ul><li><strong>无意义</strong>或<strong>当前未知</strong>的值</li><li>系统应该具有处理空值的能力<ul><li>空值的比较运算</li><li>含有空值运算对象的表达式计算</li><li>含有空值成员的集合上的统计运算</li></ul></li></ul></li></ul><h4 id="4-基于资源管理的动态联机目录"><a href="#4-基于资源管理的动态联机目录" class="headerlink" title="4. 基于资源管理的动态联机目录"></a>4. 基于资源管理的动态联机目录</h4><ul><li><strong>数据库的描述信息</strong>与<strong>用户数据</strong>具有相同的表示形式与操作方式</li><li>被授权用户可以采用同样的方式对<strong>数据库的描述信息</strong>进行查询与扩充</li></ul><h4 id="5-统一易用的数据子语言"><a href="#5-统一易用的数据子语言" class="headerlink" title="5. 统一易用的数据子语言"></a>5. 统一易用的数据子语言</h4><ul><li>至少有一种语言能全面支持下列功能<ul><li>数据定义</li><li>视图定义</li><li>数据操纵<ul><li>提供完备的关系操作</li><li>具有<strong>交互使用</strong>与<strong>程序使用</strong>两种运行方式</li></ul></li><li>完整性约束能力</li><li>授权机制</li><li>事务处理能力<ul><li>具有一定的并发控制能力</li><li>对事务生存的全过程进行控制以保证事务的正确执行</li></ul></li></ul></li></ul><h4 id="6-视图更新准则"><a href="#6-视图更新准则" class="headerlink" title="6. 视图更新准则"></a>6. 视图更新准则</h4><ul><li>用户能对视图作查询、更新操作</li></ul><h4 id="7-高级的插入、删除及修改操作"><a href="#7-高级的插入、删除及修改操作" class="headerlink" title="7. 高级的插入、删除及修改操作"></a>7. 高级的插入、删除及修改操作</h4><h4 id="8-物理数据独立性"><a href="#8-物理数据独立性" class="headerlink" title="8. 物理数据独立性"></a>8. 物理数据独立性</h4><h4 id="9-逻辑数据独立性"><a href="#9-逻辑数据独立性" class="headerlink" title="9. 逻辑数据独立性"></a>9. 逻辑数据独立性</h4><h4 id="10-数据完整性准则"><a href="#10-数据完整性准则" class="headerlink" title="10. 数据完整性准则"></a>10. 数据完整性准则</h4><ul><li>提供三类数据完整性约束的定义功能</li></ul><h4 id="11-分布独立性"><a href="#11-分布独立性" class="headerlink" title="11. 分布独立性"></a>11. 分布独立性</h4><ul><li>数据分布的改变不影响原有的应用程序</li></ul><h4 id="12-无损害原则"><a href="#12-无损害原则" class="headerlink" title="12. 无损害原则"></a>12. 无损害原则</h4><ul><li>对提供低级数据子语言的要求</li></ul><h3 id="（三）关系数据库产品的分类"><a href="#（三）关系数据库产品的分类" class="headerlink" title="（三）关系数据库产品的分类"></a>（三）关系数据库产品的分类</h3><h4 id="1-半关系型系统"><a href="#1-半关系型系统" class="headerlink" title="1. 半关系型系统"></a>1. 半关系型系统</h4><ul><li><p>基本数据结构：关系</p></li><li><p>满足<strong>12</strong>条准则中的少量要求</p></li></ul><h4 id="2-基本关系型系统"><a href="#2-基本关系型系统" class="headerlink" title="2. 基本关系型系统"></a>2. 基本关系型系统</h4><ul><li><p>基本数据结构：关系</p></li><li><p>满足<strong>12</strong>条准则中的大部分要求</p></li></ul><h4 id="3-完全关系型系统"><a href="#3-完全关系型系统" class="headerlink" title="3. 完全关系型系统"></a>3. 完全关系型系统</h4><ul><li>严格符合上述的<strong>12</strong>条准则</li></ul><h2 id="三、关系模型数学理论——关系代数"><a href="#三、关系模型数学理论——关系代数" class="headerlink" title="三、关系模型数学理论——关系代数"></a>三、关系模型数学理论<strong>——</strong>关系代数</h2><h3 id="（一）关系模型"><a href="#（一）关系模型" class="headerlink" title="（一）关系模型"></a>（一）关系模型</h3><h4 id="1-关系数据结构"><a href="#1-关系数据结构" class="headerlink" title="1. 关系数据结构"></a>1. 关系数据结构</h4><h5 id="（1）表结构"><a href="#（1）表结构" class="headerlink" title="（1）表结构"></a>（1）表结构</h5><ul><li><p>二维表组成：表框架、元组</p></li><li><p>二维表性质</p><ul><li>元组个数有限性</li><li>元组的唯一性</li><li>元组的次序无关性</li><li>元组分量的原子性</li><li>属性名唯一性</li><li>属性的次序无关性</li><li>分量值域同一性</li></ul></li><li><p>满足满足上述<strong>7</strong>个性质的二维表被称为<strong>关系</strong>，以符合上述条件的二维表为基本数据结构所建立的模型称为<strong>关系模型</strong></p></li></ul><h5 id="（2）键"><a href="#（2）键" class="headerlink" title="（2）键"></a>（2）键</h5><ul><li><p>在二维表中凡能唯一最小标识元组的属性集称为该表的<strong>键</strong>，或称<strong>关键字</strong></p><ul><li>候选键</li><li>主键<ul><li>在一张二维表的所有候选键中，被选中的一个候选键被称为该表的<strong>主键</strong>（或称<strong>主关键字</strong>）</li></ul></li></ul></li><li><p>每一张二维表都至少存在一个<strong>键</strong></p></li><li><p>外键</p><ul><li><p>如果表<strong>A</strong>中的属性集<strong>F</strong>是表<strong>B</strong>的键，则称该属性集<strong>F</strong>为表<strong>A</strong>的<strong>外键</strong>（或称<strong>外关键字</strong>）</p></li><li><p>其中：</p><ul><li><p>表<strong>A</strong>被称为<strong>引用表</strong>，表<strong>B</strong>被称为<strong>被引用表</strong></p></li><li><p>表<strong>A</strong>和表<strong>B</strong>可以是同一张二维表</p></li></ul></li></ul></li></ul><h5 id="（3）关系"><a href="#（3）关系" class="headerlink" title="（3）关系"></a>（3）关系</h5><ul><li>关系规则<ul><li>规则1：第一范式规则<ul><li>不能有多值字段</li></ul></li><li>规则2：按仅内容规则访问行<ul><li>行没有顺序、列没有顺序</li></ul></li><li>规则3：唯一行规则<ul><li>两行不能同时具有相同的所有属性</li><li>因此，一个关系是一个无序的元组集合</li></ul></li></ul></li></ul><h4 id="2-关系操纵"><a href="#2-关系操纵" class="headerlink" title="2. 关系操纵"></a>2. 关系操纵</h4><h5 id="（1）数据查询"><a href="#（1）数据查询" class="headerlink" title="（1）数据查询"></a>（1）数据查询</h5><ul><li><p>关系模型上的数据查询操作可以被分解为下面的三种基本操作方式：</p><ul><li><p>两个关系的合并</p><ul><li>通过多个关系之间的两两合并，可以将其最终合并为一个关系</li></ul></li><li><p>单个关系内的元组选择</p><ul><li>选择满足指定条件的元组</li></ul></li><li><p>单个关系内的属性指定</p><ul><li>选择结果所需要的属性（值）</li></ul></li></ul></li></ul><h5 id="（2）数据删除"><a href="#（2）数据删除" class="headerlink" title="（2）数据删除"></a>（2）数据删除</h5><ul><li><p>数据删除的基本单位是元组</p></li><li><p>操作过程是：</p><ul><li><p>确定被删除的元组</p></li><li><p>一次删除操作只能删除一个关系内的元组</p><ul><li>可采用单个关系内的元组选择操作来确定需要被删除的元组</li></ul></li><li><p>执行删除操作</p><ul><li>删除选中的元组</li></ul></li></ul></li></ul><h5 id="（3）数据插入"><a href="#（3）数据插入" class="headerlink" title="（3）数据插入"></a>（3）数据插入</h5><ul><li><p>在指定关系中插入一个或多个新的元组</p></li><li><p>一条数据插入操作只能向一个关系中增加新的元组</p></li></ul><h5 id="（4）数据修改"><a href="#（4）数据修改" class="headerlink" title="（4）数据修改"></a>（4）数据修改</h5><ul><li><p>在一个关系内修改指定元组的某些列上的值（即修改某些元组分量的值）</p></li><li><p>数据修改操作不是一个基本操作，其功能可以由其它的数据操纵方式来实现</p><ul><li><p>先删除需要修改的元组</p></li><li><p>然后插入修改后的新元组</p></li></ul></li></ul><h5 id="（5）空值的处理"><a href="#（5）空值的处理" class="headerlink" title="（5）空值的处理"></a>（5）空值的处理</h5><ul><li><p>与空值有关的数据完整性约束</p><ul><li>关系的主键中不允许出现空值</li></ul></li><li><p>需要定义有关空值的运算</p><ul><li><p>在算术表达式中如出现空值，则其运算结果也为空值；</p></li><li><p>在逻辑运算表达式中如出现空值，则其运算结果为逻辑假；</p></li><li><p>在统计计算中，对于<strong>空集</strong>和集合中的<strong>空值</strong>的处理方法</p><ul><li><p>在作<strong>SUM</strong>，<strong>AVG</strong>，<strong>MAX</strong>，<strong>MIN</strong>或<strong>COUNT</strong>统计操作时，集合中的<strong>空值</strong>元素是不统计在内的</p></li><li><p>在统计计算中，对<strong>空集</strong>的处理方法如下：</p><p>①对空集作<strong>SUM</strong>、<strong>AVG</strong>、<strong>MAX</strong>或<strong>MIN</strong>统计操作时，其统计结果均为空值</p><p>②对空集作<strong>COUNT</strong>统计操作时，其统计结果为<strong>0</strong></p></li></ul></li></ul></li></ul><h4 id="3-关系中的数据约束"><a href="#3-关系中的数据约束" class="headerlink" title="3. 关系中的数据约束"></a>3. 关系中的数据约束</h4><ul><li><p>三类数据完整性约束</p><ul><li><p>实体完整性约束</p><ul><li>主键中的属性不能有空值</li></ul></li><li><p>参照完整性约束</p><ul><li>外键要么取空值，要么是被引用表中当前存在的某元组上的主键值</li></ul></li><li><p>用户定义的完整性</p><ul><li>用户自己定义的属性取值约束</li></ul></li></ul></li></ul><h3 id="（二）关系的表示"><a href="#（二）关系的表示" class="headerlink" title="（二）关系的表示"></a>（二）关系的表示</h3><h4 id="1-关系是元组的集合"><a href="#1-关系是元组的集合" class="headerlink" title="1. 关系是元组的集合"></a>1. 关系是元组的集合</h4><ul><li>元组是元组分量的集合<ul><li>一个<strong>n</strong>元关系中的元组是一个由<strong>n</strong>个元组分量按照属性的排列次序组织起来的<strong>n</strong>元有序组</li><li>因此，一个<strong>n</strong>元关系就是一个<strong>n</strong>元有序组的集合</li></ul></li></ul><h4 id="2-笛卡尔积"><a href="#2-笛卡尔积" class="headerlink" title="2. 笛卡尔积"></a>2. 笛卡尔积</h4><h3 id="（三）关系操纵的表示"><a href="#（三）关系操纵的表示" class="headerlink" title="（三）关系操纵的表示"></a>（三）关系操纵的表示</h3><h4 id="1-关系上的五种基本操作与关系代数中的五种基本运算之间的对应关系"><a href="#1-关系上的五种基本操作与关系代数中的五种基本运算之间的对应关系" class="headerlink" title="1. 关系上的五种基本操作与关系代数中的五种基本运算之间的对应关系"></a>1. 关系上的五种基本操作与关系代数中的五种基本运算之间的对应关系</h4><table><thead><tr><th align="center">关系上的五种基本操作</th><th align="center">关系代数中的五种基本运算</th></tr></thead><tbody><tr><td align="center">元组选择</td><td align="center">选择运算</td></tr><tr><td align="center">属性指定</td><td align="center">投影运算</td></tr><tr><td align="center">关系的合并</td><td align="center">笛卡儿乘积</td></tr><tr><td align="center">元组的插入</td><td align="center">并运算</td></tr><tr><td align="center">元组的删除</td><td align="center">差运算</td></tr></tbody></table><h4 id="2-投影（Projection）运算"><a href="#2-投影（Projection）运算" class="headerlink" title="2. 投影（Projection）运算"></a>2. 投影（<strong>Projection</strong>）运算</h4><ul><li><p>略去关系中的某些列并重新安排剩余列的排列次序的运算</p></li><li><p>设关系<strong>R</strong>有$n$个属性$A_1,A_2,\cdots, A_n$，在其中$m$个属性$B_1,B_2,\cdots, B_m$上的投影运算可以表示为：<br>$$<br>\prod\ _{B_1,B_2,\cdots,B_m}(R)<br>$$</p></li></ul><p>​其中$B_i\in{A_1,A_2,\cdots,A_n}(i&#x3D;1,2,\cdots,m)$</p><ul><li><p>运算结果</p><ul><li><p>是一个由$B_1,B_2,\cdots, B_m$所组成的$m$元关系</p></li><li><p>关系<strong>R</strong>中的每个元组$t$在$B_1,B_2,\cdots, B_m$这$m$个属性上的取值$t_1,t_2,\cdots, t_m$构成结果关系中的一个元组</p></li></ul></li></ul><h4 id="3-选择运算"><a href="#3-选择运算" class="headerlink" title="3. 选择运算"></a>3. 选择运算</h4><ul><li><p>根据给定的条件<strong>F</strong>从关系<strong>R</strong>中选出符合条件的元组</p></li><li><p>结果</p><ul><li>结果关系的关系模式不变，由属于关系<strong>R</strong>且满足条件<strong>F</strong>的元组所组成</li></ul></li><li><p>条件<strong>F</strong>的构造方式</p><ul><li><p>基本逻辑条件：$\alpha\ \theta\ \beta$</p></li><li><p>复合逻辑条件：由若干个基本逻辑条件经逻辑运算符组合而成</p><ul><li>逻辑与（$\wedge$），逻辑或（$\vee$）</li></ul></li></ul></li></ul><h4 id="4-数据查询"><a href="#4-数据查询" class="headerlink" title="4. 数据查询"></a>4. 数据查询</h4><ul><li><p>可以结合使用投影和选择运算来实现单张表中的数据查询操作：$\prod_A(\sigma_F(R))$</p><ul><li><p>先根据条件<strong>F</strong>对关系<strong>R</strong>进行选择运算</p><ul><li>选出符合条件的元组</li></ul></li><li><p>再对选择运算的结果关系进行投影运算</p><ul><li><p>确定最终结果关系的关系模式</p></li><li><p>根据选择运算的结果关系中的元组构造出最终结果关系中的元组</p></li></ul></li></ul></li></ul><h3 id="（四）关系模型与关系代数"><a href="#（四）关系模型与关系代数" class="headerlink" title="（四）关系模型与关系代数"></a>（四）关系模型与关系代数</h3><ul><li><p>关系数据库中的四种类型的操作均可以用关系代数表达式来表示</p><ul><li><p>元组插入</p><ul><li>设新增加的元组构成关系$R’$，则插入操作可表示为：$R\cup R’$</li></ul></li><li><p>元组删除</p><ul><li>设欲删除的元组构成关系$R’$（可以经查询操作获得），则删除操作可表示为：$R-R’$</li></ul></li><li><p>修改操作</p><ul><li>设欲修改的元组构成关系$R’$，经修改后所生成的新元组构成关系$R’’$，则数据库的修改操作可表示为：$(R–R’)∪R’’$</li></ul></li><li><p>查询操作</p><ul><li>单个关系：选择 + 投影</li><li>多个关系：先用笛卡儿乘积将多个关系合并为一个关系，然后再执行单个关系上的数据查询操作</li></ul></li></ul></li></ul><h3 id="（五）关系代数中的扩充运算"><a href="#（五）关系代数中的扩充运算" class="headerlink" title="（五）关系代数中的扩充运算"></a>（五）关系代数中的扩充运算</h3><h4 id="1-交运算"><a href="#1-交运算" class="headerlink" title="1. 交运算"></a>1. 交运算</h4><h4 id="2-除运算：-T-x3D-R-div-S"><a href="#2-除运算：-T-x3D-R-div-S" class="headerlink" title="2. 除运算：$T&#x3D;R\div S$"></a>2. 除运算：$T&#x3D;R\div S$</h4><ul><li><p>设关系$R$和$S$的关系模式**(<strong>即它们的属性集</strong>)<strong>分别是</strong>Head($R$)** 和<strong>Head($S$)</strong></p></li><li><p>运算条件：<strong>Head($S$) $\subset$ Head($R$)</strong></p></li><li><p>关系模式：<strong>Head($T$) $&#x3D;$ Head($R$) $-$ Head($S$)</strong></p></li><li><p>结果元组：关系$S$中的<strong>所有</strong>元组在关系$R$中所对应的<strong>同一个</strong>值</p></li><li><p><strong>除</strong>运算与<strong>笛卡儿乘积</strong>的关系</p><ul><li><p>如果$R&#x3D;T\times S$，那么有：</p><ul><li>$T&#x3D;R\div S$</li><li>$S&#x3D;R\div T$</li></ul></li><li><p>如果$T&#x3D;R\div S$，那么有：</p><ul><li>$T\times S \subseteq R$</li></ul></li></ul></li></ul><h4 id="3-联接-join-运算：-R-underset-F-Join-S"><a href="#3-联接-join-运算：-R-underset-F-Join-S" class="headerlink" title="3. 联接 (join) 运算：$R\underset{F}{\Join} S$"></a>3. 联接 <strong>(join)</strong> 运算：$R\underset{F}{\Join} S$</h4><ul><li><p>设结果关系为$T$，则关系$T$与关系$R$和$S$的关系是：<strong>Head($T$) $&#x3D;$ Head($R$) $\cup_{all}$ Head($S$)</strong></p></li><li><p>从关系$R$和$S$中分别任取一个元组$r$和$s$，如果元组$r$和$s$之间满足联接条件$F$，那么可以由$r$和$s$合并构成结果关系$T$中的一个元组，即：$(r,s)\in T$</p></li><li><p>基本逻辑条件：$i\ \theta\ j$</p><ul><li>$i$是关系$R$中的属性，$j$是关系$S$中的属性</li><li>$\theta$是比较运算符：大于联接，小于联接，等值联接</li></ul></li><li><p>联接运算的推导公式<br>$$<br>R\underset{F}{\Join} S &#x3D; \sigma_F(R\times S)<br>$$</p></li><li><p>联接运算与笛卡儿乘积运算的关系</p><ul><li>设$T_1 &#x3D; R \times S$，$T_2 &#x3D; R\underset{F}{\Join} S$，则：**Head($T_2$) $&#x3D;$ Head($T_1$) 且$T_2\subseteq T_1$</li></ul></li></ul><h4 id="4-自然联接-natural-join-运算：-R-Join-S"><a href="#4-自然联接-natural-join-运算：-R-Join-S" class="headerlink" title="4. 自然联接 (natural join) 运算：$R\Join S$"></a>4. 自然联接 <strong>(natural join)</strong> 运算：$R\Join S$</h4><ul><li><p>功能：根据两个关系中的同名属性（公共属性）进行等值联接</p></li><li><p>运算条件：关系$R$和关系$S$有公共属性：**Head($R$) $\cap$ Head($S$) $\neq\varnothing$</p></li><li><p>运算结果</p><ul><li><p>结果关系的属性集合为<strong>Head($R$) $\cup$ Head($S$)</strong></p></li><li><p>结果关系中的元组：</p><ul><li><p>从关系$R$和关系$S$中分别任取一个元组$r$和$s$，如果元组$r$和元组$s$在它们的同名属性上的取值都相等，那么可以由$r$和$s$合并构成结果关系中的一个元组</p></li><li><p>同名属性上的取值在结果关系中只保留一份</p></li></ul></li></ul></li></ul><h2 id="四、-关系数据库语言SQL’92"><a href="#四、-关系数据库语言SQL’92" class="headerlink" title="四、 关系数据库语言SQL’92"></a>四、 关系数据库语言<strong>SQL’92</strong></h2><h3 id="（一）SQL数据定义功能"><a href="#（一）SQL数据定义功能" class="headerlink" title="（一）SQL数据定义功能"></a>（一）SQL数据定义功能</h3><h4 id="1-SQL基本数据类型"><a href="#1-SQL基本数据类型" class="headerlink" title="1. SQL基本数据类型"></a>1. <strong>SQL</strong>基本数据类型</h4><table><thead><tr><th align="center"></th><th align="center">符号</th><th align="center">数据类型</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">INT</td><td align="center">整数</td></tr><tr><td align="center">2</td><td align="center">SMALLINT</td><td align="center">短整数</td></tr><tr><td align="center">3</td><td align="center">DEC(m,n)</td><td align="center">十进制数</td></tr><tr><td align="center">4</td><td align="center">FLOAT</td><td align="center">浮点数</td></tr><tr><td align="center">5</td><td align="center">CHAR(n)</td><td align="center">定长字符串</td></tr><tr><td align="center">6</td><td align="center">VARCHAR(n)</td><td align="center">变长字符串</td></tr><tr><td align="center">7</td><td align="center">BIT(n)</td><td align="center">定长位串</td></tr><tr><td align="center">8</td><td align="center">BIT VARYING(n)</td><td align="center">变长位串</td></tr><tr><td align="center">9</td><td align="center">DATE</td><td align="center">日期</td></tr><tr><td align="center">10</td><td align="center">TIME</td><td align="center">时间</td></tr><tr><td align="center">11</td><td align="center">TIMESTAMP</td><td align="center">时间戳</td></tr></tbody></table><h4 id="2-基表的创建命令"><a href="#2-基表的创建命令" class="headerlink" title="2. 基表的创建命令"></a>2. 基表的创建命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tablename (<br>colname datatype [<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>]<br>&#123; , colname datatype [<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>]&#125;<br>);<br></code></pre></td></tr></table></figure><ul><li>命令的格式定义符号<ul><li>[…] &#x2F;* 0或1个 *&#x2F;</li><li>{…} &#x2F;* 0到若干个 *&#x2F;</li></ul></li></ul><h4 id="3-基表的修改命令"><a href="#3-基表的修改命令" class="headerlink" title="3. 基表的修改命令"></a>3. 基表的修改命令</h4><ul><li><p>对基表结构的修改</p><ul><li><p>表中属性的增加&#x2F;删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>基表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>基表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>数据完整性约束的修改</p></li></ul><h4 id="4-基表的删除命令"><a href="#4-基表的删除命令" class="headerlink" title="4. 基表的删除命令"></a>4. 基表的删除命令</h4><ul><li><p>删除指定的表及其数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>基表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="（二）SQL数据操纵功能"><a href="#（二）SQL数据操纵功能" class="headerlink" title="（二）SQL数据操纵功能"></a>（二）SQL数据操纵功能</h3><h4 id="1-数据查询"><a href="#1-数据查询" class="headerlink" title="1. 数据查询"></a>1. 数据查询</h4><ul><li><p><strong>SQL</strong>语言数据查询功能的数学基础来源于关系代数</p><ul><li><p>关系代数<br>$$<br>\prod\ _{A_1,A_2,\cdots,A_m}(\sigma_F(R_1\times R_2\times\cdots\times R_n))<br>$$</p></li><li><p>SQL语言</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A1, A2,..., Am<br><span class="hljs-keyword">FROM</span> R1, R2,..., Rn<br><span class="hljs-keyword">WHERE</span> F<br></code></pre></td></tr></table></figure></li></ul></li><li><p>假设：</p><p>$Head(R)&#x3D; {A_1,A_2,\cdots,A_n, B_1,\cdots, B_k}$</p><p>$Head(S)&#x3D; {B_1,B_2,\cdots,B_k, C_1,\cdots, C_m}$</p><ul><li><p>关系代数<br>$$<br>\prod\ _{A_1,A_2,\cdots,A_m}(\sigma_F(R\Join S))<br>$$</p></li><li><p>SQL语言</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A1, A2,..., Am<br><span class="hljs-keyword">FROM</span> R, S<br><span class="hljs-keyword">WHERE</span> F <span class="hljs-keyword">and</span> R.B1<span class="hljs-operator">=</span>S.B1 <span class="hljs-keyword">and</span> R.B2<span class="hljs-operator">=</span>S.B2 <span class="hljs-keyword">and</span> …… <span class="hljs-keyword">and</span> R.Bk<span class="hljs-operator">=</span>S.Bk<br></code></pre></td></tr></table></figure></li></ul></li><li><p>映像语句</p><ul><li><p>目标子句：<code>SELECT *|colname &#123;, colname ...&#125;</code></p></li><li><p>范围子句：<code>FROM tablename &#123;, tablename ...&#125;</code></p></li><li><p>条件子句：<code>[WHERE search_condition]</code></p></li><li><p>分组子句：<code>[GROUP BY colname &#123;, colname ...&#125;</code></p></li><li><p>分组查询子句：<code>[HAVING group_condition]]</code></p></li><li><p>排序输出子句：<code>[ORDER BY colname [ASC | DESC]&#123;, colname [ASC | DESC]...&#125;];</code></p></li></ul></li><li><p>常用谓词</p><ul><li>DISTINCT</li><li>BETWEEN … AND …</li><li>NOT BETWEEN … AND …</li><li>LIKE<ul><li><code>column[NOT] LIKE val1 [ESCAPE val2]</code></li><li>模版：val1<ul><li>下划线（_）： 可以匹配任意一个字符</li><li>百分号（%）： 可以匹配任意一个字符串（包括长度为 0 的空字符串）</li><li>其它字符： 只能匹配其自身</li></ul></li><li>转义指示字符：val2<ul><li>紧跟在转义指示字符 val2 之后的 ‘_’ 或 ‘%’（包括转义字符自身）不再是通配符，而是其自身</li></ul></li></ul></li><li>NOT LIKE</li><li>IS NULL</li><li>IS NOT NULL</li></ul></li><li><p>布尔表达式</p><ul><li>在 WHERE 子句中，可以使用 NOT 、 AND 与OR 这三个逻辑运算符构造出复杂的查询条件，称之为布尔表达式</li></ul></li><li><p>简单连接</p><ul><li>在 WHERE 子句中，通过两个属性之间的相等比较实现表与表之间的连接</li></ul></li><li><p>自连接</p><ul><li>在查询中，有时需要对相同的表进行连接。为了区分两张相同的表，必须在FROM子句中至少对其中之一进行换名（即定义别名），以区分开这两张表</li></ul></li><li><p>结果排序</p><ul><li><p>有时，希望查询结果能按某种顺序显示，此时须在语句后加一个排序子句 ORDER BY ，该子句具有下面的形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [ <span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span> ] &#123; , … &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-分层结构查询与集合谓词使用"><a href="#2-分层结构查询与集合谓词使用" class="headerlink" title="2. 分层结构查询与集合谓词使用"></a>2. 分层结构查询与集合谓词使用</h4><ul><li><p>分层结构指的是在一条映像语句的某个子句中嵌入另一条映像语句，被嵌入的映像语句通常称为<strong>子查询</strong></p></li><li><p>这样的子查询通常被嵌入在 WHERE 子句中，子查询的查询结果是一个集合，因此需要在 WHERE 子句中引入集合谓词</p></li><li><p>WHERE 子句中的集合谓词主要有：</p><ul><li><p>IN 谓词：标量与集合量之间的属于比较</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">expr [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">IN</span> (subquery)<br></code></pre></td></tr></table></figure></li><li><p>限定比较谓词：标量与集合中元素之间的量化比较</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">expr a <span class="hljs-keyword">ANY</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span> (subquery)<br></code></pre></td></tr></table></figure></li><li><p>EXISTS 谓词：是否为空集的判断谓词</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">[<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">EXISTS</span> (subquery)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>嵌套查询的处理顺序</p><ul><li>独立子查询：一般情况下，嵌套查询中的子查询只需要被执行一次，然后利用所获得的中间查询结果来计算外层的查询语句，处理顺序由<strong>内</strong>到<strong>外</strong></li><li>相关子查询：在有些情况下，在<strong>子查询</strong>中调用了外层查询中的表及其元组变量。随着外层元组变量的每一次的取值变化，都需要重新执行<strong>子查询</strong>以获得相关的中间查询结果。处理顺序是由<strong>外</strong>到<strong>内</strong>，直至处理完外层查询表中的所有元组</li></ul></li></ul><h4 id="3-SELECT语句间的运算"><a href="#3-SELECT语句间的运算" class="headerlink" title="3. SELECT语句间的运算"></a>3. SELECT语句间的运算</h4><ul><li><p>子查询之间的并、交、差运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>子查询<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>子查询<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span>子查询<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INTERSECT</span> [<span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>子查询<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span>子查询<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXCEPT</span> [<span class="hljs-keyword">ALL</span>] <span class="hljs-operator">&lt;</span>子查询<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-SQL计算、统计、分类的功能"><a href="#4-SQL计算、统计、分类的功能" class="headerlink" title="4. SQL计算、统计、分类的功能"></a>4. <strong>SQL</strong>计算、统计、分类的功能</h4><ul><li><p>统计功能</p><table><thead><tr><th align="center">函数名称</th><th align="center">参数类型</th><th align="center">结果类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">COUNT</td><td align="center">any (can be *)</td><td align="center">numeric</td><td align="center">count of rows</td></tr><tr><td align="center">SUM</td><td align="center">numeric</td><td align="center">numeric</td><td align="center">sum of argument</td></tr><tr><td align="center">AVG</td><td align="center">numeric</td><td align="center">numeric</td><td align="center">average of argument</td></tr><tr><td align="center">MAX</td><td align="center">char or numeric</td><td align="center">same as argument</td><td align="center">maximum value</td></tr><tr><td align="center">MIN</td><td align="center">char or numeric</td><td align="center">same as argument</td><td align="center">minimum value</td></tr></tbody></table></li><li><p>计算功能</p></li><li><p>分类功能</p><ul><li><p>分类（组）统计查询</p><ul><li><p>分组查询子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> colname &#123;, colname ...&#125;<br></code></pre></td></tr></table></figure><ul><li><p>根据属性 colname 的取值的不同，将满足WHERE 条件的元组划分为不同的集合</p></li><li><p>使用GROUP BY子句的目的：可以在SELECT子句中针对不同的元组集合分别进行统计计算，实现分类统计查询</p></li></ul></li><li><p>分组查询子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">HAVING</span> group_condition<br></code></pre></td></tr></table></figure><ul><li>根据 GROUP BY 子句的分组结果，定义分组查询条件</li><li>在 HAVING 子句中给出的查询条件是定义在分组后的元组集合上的，通常是根据该集合上的某种统计计算的结果来定义查询条件</li></ul></li></ul></li><li><p>GROUP BY &amp; HAVING 此两子句可以对映像语句所得到的集合元组分组（用 GROUP BY 子句），并还可利用 HAVING 子句设置逻辑条件</p></li></ul></li></ul><h4 id="5-SELECT语句使用的一般规则"><a href="#5-SELECT语句使用的一般规则" class="headerlink" title="5. SELECT语句使用的一般规则"></a>5. <strong>SELECT</strong>语句使用的一般规则</h4><ul><li>映像语句的处理顺序<ul><li>合并 FROM 子句中的表（笛卡儿乘积）</li><li>利用 WHERE 子句中的条件进行元组选择，抛弃不满足 WHERE 条件的那些元组</li><li>根据 GROUP BY 子句对保留下来的元组进行分组</li><li>利用 HAVING 子句中的条件对分组后的元组集合（group）进行选择，抛弃不满足 HAVING 条件的那些元组集合</li><li>根据 SELECT 子句进行统计计算，生成结果关系中的元组： a group $\to$ a result row</li><li>根据 ORDER BY 子句对查询结果进行排序</li></ul></li></ul><h3 id="（三）SQL的更新功能"><a href="#（三）SQL的更新功能" class="headerlink" title="（三）SQL的更新功能"></a>（三）SQL的更新功能</h3><h4 id="1-删除功能"><a href="#1-删除功能" class="headerlink" title="1. 删除功能"></a>1. 删除功能</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name<br>[<span class="hljs-keyword">WHERE</span> search_condition];<br></code></pre></td></tr></table></figure><ul><li>在 table_name 表中删除符合条件 search_condition 的元组</li><li>在省略 WHERE 子句的情况下，删除表 table_name 中的所有元组</li><li>WHERE 子句的构造方式与映像语句中的 WHERE 子句一样，也可以在其中嵌入子查询（subquery）</li></ul><h4 id="2-元组插入功能"><a href="#2-元组插入功能" class="headerlink" title="2. 元组插入功能"></a>2. 元组插入功能</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tablename [(colname &#123; , colname … &#125;)]<br><span class="hljs-keyword">VALUES</span> (expr <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> &#123; , expr <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> … &#125;)<span class="hljs-operator">|</span> subquery;<br></code></pre></td></tr></table></figure><ul><li>属性名列表可以被省略。在此情况下，属性的排列顺序采用基表定义中的顺序</li><li>被插入的常量元组值中，属性值的数量及其排列顺序必须与 INTO 子句中的属性名列表一致</li><li>子查询结果属性的排列顺序必须与 INTO 子句中的顺序一致</li></ul><h4 id="3-修改功能"><a href="#3-修改功能" class="headerlink" title="3. 修改功能"></a>3. 修改功能</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> colname <span class="hljs-operator">=</span> expr <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> subquery, ......<br>[<span class="hljs-keyword">WHERE</span> search_condition];<br></code></pre></td></tr></table></figure><ul><li>修改指定基表 table_name 中满足 WHERE 条件的元组<ul><li>即：用 SET 子句中的赋值语句修改相关元组上的属性值</li></ul></li></ul><h3 id="（四）视图"><a href="#（四）视图" class="headerlink" title="（四）视图"></a>（四）视图</h3><h4 id="1-视图定义"><a href="#1-视图定义" class="headerlink" title="1. 视图定义"></a>1. 视图定义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> &#123; , <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> … &#125;)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>映像语句<span class="hljs-operator">&gt;</span> [ <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION ]<br></code></pre></td></tr></table></figure><ul><li>创建一个以 &lt;视图名&gt; 为表名的视图，对应的数据查询语句是映像语句。以&lt;映像语句&gt;作查询所得到的查询结果即是该视图中的元组</li><li>如果没有给视图中的属性命名，则用&lt;映像语句&gt;的 SELECT 子句中的属性名作为视图属性的属性名。否则视图中的属性必需与&lt;映像语句&gt;的 SELECT 子句中的结果属性一一对应</li><li>WITH CHECK OPTION 用于约束视图上的修改操作： 如果允许在该视图上执行更新操作，则其更新后的结果元组仍然必需满足视图的定义条件。即通过该视图插入或修改后的新元组能够通过该视图上的查询操作查出来</li></ul><h4 id="2-视图的删除"><a href="#2-视图的删除" class="headerlink" title="2. 视图的删除"></a>2. 视图的删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在执行视图的删除操作时，将连带删除定义在该视图上的其它视图</li></ul><h4 id="3-视图上的操作"><a href="#3-视图上的操作" class="headerlink" title="3. 视图上的操作"></a>3. 视图上的操作</h4><ul><li>对视图可以作查询操作<ul><li>视图上的查询操作将首先被改写为基表上的查询操作，然后才能得到执行</li></ul></li><li>一般不允许执行视图上的更新操作，只有在特殊情况下才可以进行：<ul><li>视图的每一行必须对应基表的惟一一行</li><li>视图的每一列必须对应基表的惟一一列</li></ul></li></ul><h4 id="4-视图的优点"><a href="#4-视图的优点" class="headerlink" title="4. 视图的优点"></a>4. 视图的优点</h4><ul><li><p>提高了数据独立性</p></li><li><p>简化用户观点</p></li><li><p>提供自动的安全保护功能</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级程序设计二：继承——派生类</title>
    <link href="/2022/10/12/AP2/"/>
    <url>/2022/10/12/AP2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、继承的基本概念"><a href="#一、继承的基本概念" class="headerlink" title="一、继承的基本概念"></a>一、继承的基本概念</h2><h3 id="（一）软件复用"><a href="#（一）软件复用" class="headerlink" title="（一）软件复用"></a>（一）软件复用</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li>在开发一个新软件时，把现有软件或软件的一部分拿过来用称为<strong>软件复用</strong>。</li></ul><h4 id="2-解决已有软件与新软件功能差别的方法"><a href="#2-解决已有软件与新软件功能差别的方法" class="headerlink" title="2. 解决已有软件与新软件功能差别的方法"></a>2. 解决已有软件与新软件功能差别的方法</h4><ul><li>修改已有软件的源代码<ul><li>缺点：需读懂源代码，可靠性差、易出错，有时源代码难以获得</li></ul></li><li>函数库<ul><li>缺点：除了一些最基本的函数（如数学函数），已有软件的函数不是为新软件设计的，常常不完全符合新软件的功能要求。</li></ul></li></ul><h3 id="（二）继承的基本概念"><a href="#（二）继承的基本概念" class="headerlink" title="（二）继承的基本概念"></a>（二）继承的基本概念</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li>在定义一个新的类时，先把已有的一个或多个类的功能全部包含进来，然后再在新的类中给出新功能的定义或对已有类的某些功能进行重新定义，这个机制称为继承（Inheritance）。</li><li>继承不需要已有软件的源代码，属于目标代码复用！</li></ul><h4 id="2-基类与派生类"><a href="#2-基类与派生类" class="headerlink" title="2. 基类与派生类"></a>2. 基类与派生类</h4><ul><li>继承关系中存在着两个类：<strong>基类（父类）</strong>和<strong>派生类（子类）</strong>。</li><li>派生类拥有<strong>基类的所有成员</strong>，并可以<ul><li>定义<strong>新成员</strong></li><li>对基类的一些成员（成员函数）进行<strong>重定义</strong>（override）。</li></ul></li><li>继承分为<strong>单继承</strong>和<strong>多继承</strong><ul><li>单继承：一个类只有<strong>一个直接基类</strong></li><li>多继承：一个类有<strong>多个直接基类</strong><br>  <img src="/img/posts/AP-2-1.png" alt="这是图片" title="单继承与多继承"></li></ul></li></ul><h4 id="3-继承对程序设计的支持"><a href="#3-继承对程序设计的支持" class="headerlink" title="3. 继承对程序设计的支持"></a>3. 继承对程序设计的支持</h4><ul><li>继承机制除了支持软件复用外，它还具有下面的作用： <ul><li>对处理的对象按层次进行分类<ul><li>有利于问题的描述和解决</li></ul></li><li>对概念进行组合<ul><li>给新类的设计进一步带来便利</li></ul></li><li>支持软件的增量开发（版本升级）<ul><li>这给软件开发和维护带来便利</li></ul></li></ul></li></ul><h3 id="（三）单继承"><a href="#（三）单继承" class="headerlink" title="（三）单继承"></a>（三）单继承</h3><h4 id="1-单继承派生类的定义"><a href="#1-单继承派生类的定义" class="headerlink" title="1. 单继承派生类的定义"></a>1. 单继承派生类的定义</h4><ul><li><p>在定义单继承时，派生类只能有一个<strong>直接基类</strong>，其定义格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> &lt;派生类名&gt;:[&lt;继承方式&gt;] &lt;基类名&gt;<br>&#123;&lt;成员说明表&gt;<br>&#125;; <br></code></pre></td></tr></table></figure><ul><li>&lt;派生类名&gt;为派生类的名字。</li><li>&lt;基类名&gt;为直接基类的名字。</li><li>&lt;成员说明表&gt;是在派生类中<strong>新定义</strong>的成员，其中包括对基类成员的<strong>重定义</strong>。</li><li>&lt;继承方式&gt;用于指出从基类继承来的成员在派生类中对外的访问控制</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-comment">//基类</span><br>&#123;<br>    <span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A <span class="hljs-comment">//派生类</span><br>&#123;<br>    <span class="hljs-type">int</span> z; <span class="hljs-comment">//新成员</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//新成员</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>派生类除了拥有新定义的成员外，还拥有基类的所有成员（基类的构造函数、析构函数和赋值操作符重载函数除外）。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-comment">//基类</span><br>&#123;<br>    <span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A <span class="hljs-comment">//派生类</span><br>&#123;<br>    <span class="hljs-type">int</span> z; <span class="hljs-comment">//新成员</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//新成员</span><br>&#125;;<br>B b;<br>b.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//A类中的f</span><br>b.<span class="hljs-built_in">g</span>(); <span class="hljs-comment">//A类中的g</span><br>b.<span class="hljs-built_in">h</span>(); <span class="hljs-comment">//B类中的h</span><br></code></pre></td></tr></table></figure><div align=center><img src="/img/posts/AP-2-2.png" title="" height="25%" width="25%" /></div></li><li><p>定义派生类时一定要见到基类的定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>; <span class="hljs-comment">//声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A <span class="hljs-comment">//Error</span><br>&#123;<br><span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">g</span>(); &#125; <span class="hljs-comment">//Error，编译程序不知道基类中是否有函数g。</span><br>&#125;;<br>......<br>B b; <span class="hljs-comment">//Error，编译无法确定b所需内存空间的大小。</span><br></code></pre></td></tr></table></figure></li><li><p>友元：</p><ul><li><p>如果在派生类中没有显式说明，则基类的友元不是派生类的友元</p></li><li><p>如果基类是另一个类的友元，而该类没有显式说明，则派生类也不是该类的友元</p></li></ul></li></ul><h4 id="2-在派生类中访问基类成员"><a href="#2-在派生类中访问基类成员" class="headerlink" title="2. 在派生类中访问基类成员"></a>2. 在派生类中访问基类成员</h4><ul><li><p>C++中，派生类不能直接访问基类的私有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; ... x ，y ... &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;... x，y ...  <span class="hljs-comment">//Error，x、y为基类的私有成员。</span><br><span class="hljs-built_in">f</span>();  <span class="hljs-comment">//OK</span><br><span class="hljs-built_in">g</span>();  <span class="hljs-comment">//OK，通过函数g访问基类的私有成员x和y。</span><br>&#125;<br>&#125;; <br></code></pre></td></tr></table></figure></li><li><p>继承与封装的矛盾</p><ul><li><p>在派生类中定义新的成员函数或对基类已有成员函数重定义时，往往需要直接访问基类的一些private成员</p><ul><li>特别是private数据成员</li><li>否则新功能无法实现</li></ul></li><li><p>而类的private成员是不允许外界使用的（数据封装）</p></li></ul></li><li><p>实际上，有了继承机制以后，一个类的成员有两种被外界使用的场合：</p><ul><li><p>通过类的对象（实例）使用</p></li><li><p>在派生类中使用</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123; ......<br>  m<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; A a;<br>  ... a.m ... <span class="hljs-comment">//通过A的对象（实例）使用A的成员m</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123; ......<br>  <span class="hljs-built_in">f</span>() &#123; ... m ...&#125; <span class="hljs-comment">//通过派生类使用A的成员m</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>protected访问控制</p><ul><li><p>用protected说明的成员不能通过对象使用，但可以在派生类中使用。</p></li><li><p>protected访问控制<strong>缓解了</strong>封装与继承的矛盾</p></li><li><p>C++类向外界提供两种接口：</p><ul><li><p>public：通过对象（类的实例用户）使用</p></li><li><p>public+protected：供派生类使用</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;......<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-built_in">f</span>();  <span class="hljs-comment">//OK</span><br>... x ...  <span class="hljs-comment">//OK</span><br>... y ...  <span class="hljs-comment">//OK</span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;A a;<br>a.<span class="hljs-built_in">f</span>();  <span class="hljs-comment">//OK</span><br>... a.x ...  <span class="hljs-comment">//Error</span><br>... a.y ...  <span class="hljs-comment">//Error</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>一般情况下，应该把今后不太可能发生变动的、有可能被派生类使用的、不宜对实例用户公开的成员声明为protected。</li></ul></li></ul><h4 id="3-派生类成员标识符的作用域"><a href="#3-派生类成员标识符的作用域" class="headerlink" title="3. 派生类成员标识符的作用域"></a>3. 派生类成员标识符的作用域</h4><ul><li><p>派生类对基类成员的访问除了受到基类的访问控制的限制以外，还要受到标识符作用域（scope）的限制。</p></li><li><p>对基类而言，派生类成员标识符的作用域是<strong>嵌套在</strong>基类作用域中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;  ......<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">g</span>(); &#125; <span class="hljs-comment">//Error!</span><br>    ......<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123; ......<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">f</span>(); &#125; <span class="hljs-comment">//OK</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果派生类中定义了与基类同名的成员，则基类的成员名在派生类的作用域内不直接可见（被隐藏，Hidden）。访问基类同名成员时要用基类名受限。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-comment">//基类</span><br>&#123;<br>    <span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//B类中的f</span><br>A::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//A类中的f</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>即使派生类中定义了与基类同名但参数不同的成员函数，基类的同名函数在派生类的作用域中也是不直接可见的，仍然需要用基类名受限方式来使用之：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">//不是重载A的f！</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//OK</span><br>        <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//Error</span><br>        A::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>注意：B类中的f与A类中的f不属于函数名重载，因为它们属于不同的作用域。</li></ul></li><li><p>也可以在派生类中使用using声明把基类中某个的函数名对派生类开放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A::f;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//OK</span><br>        <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，等价于A::f();</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-基类成员在派生类中对外的访问控制"><a href="#4-基类成员在派生类中对外的访问控制" class="headerlink" title="4. 基类成员在派生类中对外的访问控制"></a>4. 基类成员在派生类中对外的访问控制</h4><h3 id="（五）protected访问控制"><a href="#（五）protected访问控制" class="headerlink" title="（五）protected访问控制"></a>（五）protected访问控制</h3><h3 id="（六）继承方式与子类型"><a href="#（六）继承方式与子类型" class="headerlink" title="（六）继承方式与子类型"></a>（六）继承方式与子类型</h3><h3 id="（七）派生类对象的初始化与消亡处理"><a href="#（七）派生类对象的初始化与消亡处理" class="headerlink" title="（七）派生类对象的初始化与消亡处理"></a>（七）派生类对象的初始化与消亡处理</h3><h3 id="（八）派生类对象的赋值"><a href="#（八）派生类对象的赋值" class="headerlink" title="（八）派生类对象的赋值"></a>（八）派生类对象的赋值</h3>]]></content>
    
    
    <categories>
      
      <category>高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中vector使用方法</title>
    <link href="/2022/09/30/vector/"/>
    <url>/2022/09/30/vector/</url>
    
    <content type="html"><![CDATA[<p>在C++中，vector是一个十分有用的容器，是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p><p><strong>vector的优点</strong>:<br>（1）可将容器中元素翻转、复制元素、找到元素值对应的位置<br>（2）迭代器可以按照不同的方式遍历容器<br>（3）可在容器的末尾增加或删除元素<br>（4）可在任意位置插入数据<br>与数组相比，容器在自动处理容量的大小时会消耗更多的内存，但能很好的调整存储空间大小。</p><h2 id="一-基本操作"><a href="#一-基本操作" class="headerlink" title="一. 基本操作"></a>一. 基本操作</h2><h3 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件:"></a>1. 头文件:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-创建vector对象"><a href="#2-创建vector对象" class="headerlink" title="2. 创建vector对象:"></a>2. 创建vector对象:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; array;<br></code></pre></td></tr></table></figure><h3 id="3-向量尾部插入-x2F-删除元素："><a href="#3-向量尾部插入-x2F-删除元素：" class="headerlink" title="3. 向量尾部插入&#x2F;删除元素："></a>3. 向量尾部插入&#x2F;删除元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">push_back</span>(a); <span class="hljs-comment">//尾部插入数字a</span><br>array.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//删除向量的最后一个元素</span><br></code></pre></td></tr></table></figure><h3 id="4-使用下标访问元素"><a href="#4-使用下标访问元素" class="headerlink" title="4. 使用下标访问元素:"></a>4. 使用下标访问元素:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array[<span class="hljs-number">0</span>],array[<span class="hljs-number">1</span>]......array[n]<br>array.<span class="hljs-built_in">at</span>(i) <span class="hljs-comment">//使用at(),当这个函数越界时会抛出一个异常</span><br></code></pre></td></tr></table></figure><h3 id="5-使用迭代器访问元素"><a href="#5-使用迭代器访问元素" class="headerlink" title="5. 使用迭代器访问元素:"></a>5. 使用迭代器访问元素:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it=array.<span class="hljs-built_in">begin</span>();it!=array.<span class="hljs-built_in">end</span>();it++)<br>    cout&lt;&lt;*it&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h3 id="6-插入元素："><a href="#6-插入元素：" class="headerlink" title="6. 插入元素："></a>6. 插入元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">insert</span>(array.<span class="hljs-built_in">begin</span>()+i,a); <span class="hljs-comment">//在第i+1个元素前面插入a;</span><br></code></pre></td></tr></table></figure><h3 id="7-删除元素："><a href="#7-删除元素：" class="headerlink" title="7. 删除元素："></a>7. 删除元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">erase</span>(array.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>); <span class="hljs-comment">//删除第3个元素</span><br>array.<span class="hljs-built_in">erase</span>(array.<span class="hljs-built_in">begin</span>()+i,array.<span class="hljs-built_in">end</span>()+j); <span class="hljs-comment">//删除区间[i,j-1],区间从0开始</span><br></code></pre></td></tr></table></figure><h3 id="8-向量大小"><a href="#8-向量大小" class="headerlink" title="8. 向量大小:"></a>8. 向量大小:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h3 id="9-清空"><a href="#9-清空" class="headerlink" title="9. 清空:"></a>9. 清空:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure><h3 id="10-判空："><a href="#10-判空：" class="headerlink" title="10. 判空："></a>10. 判空：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//当元素个数为0时返回true，否则为false</span><br></code></pre></td></tr></table></figure><h3 id="11-返回最后一个元素："><a href="#11-返回最后一个元素：" class="headerlink" title="11. 返回最后一个元素："></a>11. 返回最后一个元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">back</span>();<br></code></pre></td></tr></table></figure><h3 id="12-返回第一个元素："><a href="#12-返回第一个元素：" class="headerlink" title="12. 返回第一个元素："></a>12. 返回第一个元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">front</span>();<br></code></pre></td></tr></table></figure><h3 id="13-返回内存中总共可以容纳的元素个数："><a href="#13-返回内存中总共可以容纳的元素个数：" class="headerlink" title="13. 返回内存中总共可以容纳的元素个数："></a>13. 返回内存中总共可以容纳的元素个数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array.<span class="hljs-built_in">capacity</span>();<br></code></pre></td></tr></table></figure><h3 id="14-调整元素个数："><a href="#14-调整元素个数：" class="headerlink" title="14. 调整元素个数："></a>14. 调整元素个数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span><br>a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span><br></code></pre></td></tr></table></figure><h3 id="15-扩充容量："><a href="#15-扩充容量：" class="headerlink" title="15. 扩充容量："></a>15. 扩充容量：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//将a的容量（capacity）扩充至100</span><br></code></pre></td></tr></table></figure><h3 id="16-两向量交换："><a href="#16-两向量交换：" class="headerlink" title="16. 两向量交换："></a>16. 两向量交换：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a.<span class="hljs-built_in">swap</span>(b); <span class="hljs-comment">//将a中的元素和b中的元素进行整体性交换</span><br></code></pre></td></tr></table></figure><h3 id="17-向量的比较："><a href="#17-向量的比较：" class="headerlink" title="17. 向量的比较："></a>17. 向量的比较：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">向量的比较操作 == != &gt;= &lt;= &gt; &lt;  <br>a==b;<br></code></pre></td></tr></table></figure><p><strong>重要说明</strong>：vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。</p><h2 id="二-算法"><a href="#二-算法" class="headerlink" title="二. 算法"></a>二. 算法</h2><p><strong>注意</strong>：进行如下操作需要加头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-使用reverse将元素翻转："><a href="#1-使用reverse将元素翻转：" class="headerlink" title="1. 使用reverse将元素翻转："></a>1. 使用reverse将元素翻转：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">reverse</span>(array.<span class="hljs-built_in">begin</span>(),array.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//将元素翻转，即逆序排列</span><br></code></pre></td></tr></table></figure><p>注：在vector中，如果一个函数中需要两个迭代器，一般后一个都不包含.</p><h3 id="2-使用sort排序："><a href="#2-使用sort排序：" class="headerlink" title="2. 使用sort排序："></a>2. 使用sort排序：</h3><p>默认升序：<code>cpp sort(array.begin(),array.end());</code><br>降序则调用: <code>cpp sort(array.begin(),array.end(),Comp);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Comp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-复制向量的元素："><a href="#3-复制向量的元素：" class="headerlink" title="3. 复制向量的元素："></a>3. 复制向量的元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">copy</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),b.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>); <br><span class="hljs-comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span><br></code></pre></td></tr></table></figure><h3 id="4-查找元素的位置："><a href="#4-查找元素的位置：" class="headerlink" title="4. 查找元素的位置："></a>4. 查找元素的位置：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">find</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-number">10</span>); <br><span class="hljs-comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span><br></code></pre></td></tr></table></figure><h2 id="三-输出vector的中的元素（三种方法）"><a href="#三-输出vector的中的元素（三种方法）" class="headerlink" title="三. 输出vector的中的元素（三种方法）"></a>三. 输出vector的中的元素（三种方法）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">float</span>&gt; vecClass; <br><span class="hljs-type">int</span> nSize = vecClass.<span class="hljs-built_in">size</span>();   <br><span class="hljs-comment">//方法一（下标方式）打印vecClass </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nSize;i++)    <br>&#123;    <br>   cout&lt;&lt;vecClass[i]&lt;&lt;<span class="hljs-string">&quot;     &quot;</span>;    <br>&#125;    <br>cout&lt;&lt;endl;   <br><span class="hljs-comment">//方法二（下标方式）打印vecClass     </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nSize;i++)    <br>&#123;    <br>   cout&lt;&lt;vecClass.<span class="hljs-built_in">at</span>(i)&lt;&lt;<span class="hljs-string">&quot;     &quot;</span>;    <br>&#125;    <br>cout&lt;&lt;endl;    <br><span class="hljs-comment">//方法三（遍历器方式）打印vecClass：输出某一指定的数值时不方便</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">float</span>&gt;::iterator it = vecClass.<span class="hljs-built_in">begin</span>();it!=vecClass.<span class="hljs-built_in">end</span>();it++)    <br>&#123;    <br>    cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot;   &quot;</span>;    <br>&#125;    <br>cout&lt;&lt;endl;    <br></code></pre></td></tr></table></figure><p>转载自：<a href="https://blog.csdn.net/weixin_44607113/article/details/123738389">https://blog.csdn.net/weixin_44607113/article/details/123738389</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库概论二：数据模型</title>
    <link href="/2022/09/13/database_note_2/"/>
    <url>/2022/09/13/database_note_2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据模型的基本概念"><a href="#一、数据模型的基本概念" class="headerlink" title="一、数据模型的基本概念"></a>一、数据模型的基本概念</h2><h3 id="（一）数据与数据模型"><a href="#（一）数据与数据模型" class="headerlink" title="（一）数据与数据模型"></a>（一）数据与数据模型</h3><ol><li><p>数据是对于现实世界的符号抽象，而数据模型则是对数据特征的抽象， 为数据库系统的信息表示和操作提供一个抽象框架，是数据库系统的核心与基础</p></li><li><p>数据模型应该能比较真实地模拟现实世界、易于人理解、便于在计算机上实现<br> $$ 现实世界 \xrightarrow{符号化} 数据 \xrightarrow{特征抽象} 数据模型$$</p></li></ol><h3 id="（二）数据模型（data-model）"><a href="#（二）数据模型（data-model）" class="headerlink" title="（二）数据模型（data model）"></a>（二）数据模型（data model）</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul><li>描述数据的结构，定义在该数据结构上可以执行的操作以及数据之间必须满足的约束条件</li></ul><h4 id="2-组成"><a href="#2-组成" class="headerlink" title="2. 组成"></a>2. 组成</h4><ul><li>数据结构<ul><li>描述数据的类型、内容、性质以及数据间的联系 <ul><li>数据结构是一个数据模型的基础，数据操作与数据约束均是建立在相应的数据结构上的</li><li>这也是不同类型数据模型的划分依据</li></ul></li></ul></li><li>数据操作<ul><li>在相应数据结构上可以执行的操作类型与操作方式<ul><li>在不同的数据结构上可以提供不同的操作方式与操作类型</li></ul></li></ul></li><li>数据约束<ul><li>主要描述数据结构内数据间的相互关系，包括：<ul><li>数据间的语法、语义联系</li><li>数据间的制约与依存关系</li><li>数据（间）的动态变化规则</li></ul></li><li>其目的是确保数据的正确、有效与相容</li></ul></li></ul><h4 id="3-按不同的应用层次分成三种类型"><a href="#3-按不同的应用层次分成三种类型" class="headerlink" title="3. 按不同的应用层次分成三种类型"></a>3. 按不同的应用层次分成三种类型</h4><ul><li>概念数据模型<ul><li>侧重于对客观世界中复杂事物的结构描述及它们之间的内在联系的刻划，不涉及具体的描述细节和物理实现因素<ul><li>是一种面向客观世界和用户的模型，与具体采用的 DBMS 及计算机实现无关</li><li>主要的几种概念模型<ul><li>E-R 模型，EE-R 模型</li><li>面向对象模型</li><li>谓词模型</li></ul></li></ul></li><li>概念数据模型主要描述这些客观对象的数据特征及其相互关系</li><li>例：学生，教师，运动员，教练<ul><li>这些客观对象的数据特征如下：    <table><thead><tr><th align="center">对象</th><th align="center">数据特征</th></tr></thead><tbody><tr><td align="center">学生</td><td align="center">学号，姓名，系，专业，性别，入学年份</td></tr><tr><td align="center">教师</td><td align="center">姓名，性别，出生日期，职称，学历，参加工作时间，工作证编号，身份证号</td></tr><tr><td align="center">运动员</td><td align="center">姓名，性别，出生日期，从事运动项目，身高，体重</td></tr><tr><td align="center">教练员</td><td align="center">姓名，性别，出生日期，职称，从事运动项目，参加工作时间，工作证编号，身份证号</td></tr></tbody></table></li><li>相互关系的描述：</li></ul></li></ul></li></ul><p><img src="/img/posts/DB-2-1.jpg" alt="这是图片" title="相互关系描述"></p><ul><li><p>逻辑数据模型</p><ul><li>着重于数据模型在数据库系统一级的实现，即利用具体的 DBMS 所提供的工具（DDL）来定义的数据模型<ul><li>是一种面向数据库系统的模型，概念数据模型只有在转换成逻辑数据模型后才能在数据库中得以表示</li><li>是一个中介模型，具有承上启下的作用</li></ul></li><li>成熟并（曾经）得到大量使用的逻辑数据模型有：<ul><li>层次模型、网状模型</li><li>关系模型、面向对象模型、谓词模型</li><li>对象关系模型</li></ul></li><li>需要描述每个客观事物及其相互关系在选定的 DBMS 中的实现结构</li><li>即根据选定的 DBMS 来定义客观事物及其相互关系的实现结构</li><li>例如：<ul><li>客观事物的实现结构：<ul><li>关系数据库：表及其属性的定义，如<ul><li>属性的名称、数据类型、取值约束等</li><li>表级的取值约束</li></ul></li><li>面向对象数据库：类及其属性、方法的定义</li></ul></li><li>相互关系的实现结构<ul><li>关系数据库：表及其外键</li><li>面向对象数据库：类的继承与合成关系</li></ul></li></ul></li></ul></li><li><p>物理数据模型</p><ul><li>给出了数据模型在计算机内部的真正物理结构，是一种面向计算机物理实现的模型</li><li>一个概念数据模型将首先被转化为某一种逻辑数据模型，并通过所选择的 DBMS 将其进一步转化为具体的物理数据模型，才能使其在计算机中得以物理实现</li><li>大都由选定的某种 DBMS 来负责数据库物理存储结构的选择，但也向用户提供了一些与物理存储结构和存取方法有关的定义功能，如：</li><li>索引（index）的定义</li><li>集簇（cluster）的定义</li><li>存储区域的选择</li><li>例如：Oracle用户可以选择表中数据的物理存储所使用的表空间（tablespace）等</li></ul></li></ul><h4 id="4-三种“数据模型”与“三级模式”之间的关系"><a href="#4-三种“数据模型”与“三级模式”之间的关系" class="headerlink" title="4. 三种“数据模型”与“三级模式”之间的关系"></a>4. 三种“数据模型”与“三级模式”之间的关系</h4><p><img src="/img/posts/DB-2-2.jpg" alt="这是图片" title="相互关系描述"></p><h2 id="二、数据模型的四个世界"><a href="#二、数据模型的四个世界" class="headerlink" title="二、数据模型的四个世界"></a>二、数据模型的四个世界</h2><h4 id="1-现实世界"><a href="#1-现实世界" class="headerlink" title="1. 现实世界"></a>1. 现实世界</h4><ul><li>在客观世界中根据用户的需求目标而划定边界的一个应用环境</li><li>用户需求：数据需求、处理要求<ul><li>从而确定了数据库应支持的应用功能<br>和应用范围</li></ul></li><li>现实世界为整个转换过程提供了客观基础与初始启动环境</li></ul><h4 id="2-概念世界"><a href="#2-概念世界" class="headerlink" title="2. 概念世界"></a>2. 概念世界</h4><ul><li>以现实世界为基础作进一步的抽象而形成的概念模型</li><li>基本概念与基本关系可以用所选择的某一种概念数据模型中所提供的术语和方法来统一表示</li><li>概念世界中的基本术语<ul><li>例：ER模型：实体，属性，联系</li><li>例：OO模型：对象，类，方法，继承，……</li><li>概念世界与具体的 DBMS 和计算机无关</li></ul></li></ul><h4 id="3-信息世界"><a href="#3-信息世界" class="headerlink" title="3. 信息世界"></a>3. 信息世界</h4><ul><li>以概念世界为基础，选用特定的 DBMS 构造而成的逻辑数据模型<ul><li>侧重于概念数据模型的细化和在数据库系统一级的实现，即利用特定的 DBMS 所提供的工具来定义逻辑数据模型</li><li>该模型的定义与具体的 DBMS 有关</li></ul></li></ul><h4 id="4-计算机世界"><a href="#4-计算机世界" class="headerlink" title="4. 计算机世界"></a>4. 计算机世界</h4><ul><li>基于逻辑数据模型在计算机中的物理实现而形成的物理数据模型<ul><li>侧重于数据库物理存储结构的描述<ul><li>存储结构的设计</li><li>存取路径的设计<ul><li>文件结构的选择：堆&#x2F;直接&#x2F;索引 文件等</li><li>索引&#x2F;集簇 的设计</li></ul></li><li>存储空间的分配</li></ul></li><li>是 DB 的最终实现结构</li></ul></li></ul><p>$$现实世界 \to 概念世界 \to 信息世界 \to 计算机世界 $$</p><h2 id="三、概念世界与概念模型"><a href="#三、概念世界与概念模型" class="headerlink" title="三、概念世界与概念模型"></a>三、概念世界与概念模型</h2><h3 id="（一）实体-联系模型（Entity-Relationship-model，简称E-R模型）"><a href="#（一）实体-联系模型（Entity-Relationship-model，简称E-R模型）" class="headerlink" title="（一）实体-联系模型（Entity Relationship model，简称E-R模型）"></a>（一）实体-联系模型（Entity Relationship model，简称E-R模型）</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul><li>这是一种概念化的模型，它将现实世界的要求转化成实体、联系、属性等基本概念及它们之间的两种基本关系，并且用一种较为简单的图表示，称<strong>E-R图</strong>（Entity Relationship diagram）</li></ul><h4 id="2-E-R模型中的基本概念"><a href="#2-E-R模型中的基本概念" class="headerlink" title="2. E-R模型中的基本概念"></a>2. E-R模型中的基本概念</h4><ul><li><p>实体（Entity）</p><ul><li>客观存在且又能相互区别的事物<ul><li>是对现实世界中的客观事物的抽象，是概念世界中的基本单位</li></ul></li><li>实体集<ul><li>由具有共性的实体所构成的集合</li></ul></li></ul></li><li><p>属性（Attribute）</p><ul><li>实体所具有的某种特性或特征<ul><li>属性可以有值</li><li>一个属性可以取的值的集合，被称为该属性的<strong>值域</strong>（value domain）</li></ul></li><li>一个实体可以有多个属性<ul><li>所谓具有共性的实体是指这些实体含有相同的属性组成</li><li>不同的实体在这些属性上的取值则存在着区别</li></ul></li></ul></li><li><p>联系（Relationship）</p><ul><li>一个实体集中的实体与另一个实体集中的实体之间的对应关系。在概念世界中，我们用两个实体集的联系来反映它们之间的这种关系</li><li>联系的种类（与联系相关的实体集的个数）<ul><li>两个实体集间的联系（二元联系）</li><li>多个实体集间的联系（多元联系）</li><li>单个实体集内部的联系</li></ul></li><li>联系的例子<ul><li>两个实体集之间的联系<ul><li>隶属关系（教师，系别）</li><li>学习关系（学生，课程）</li><li>借阅关系（学生，图书）</li></ul></li><li>多个实体集之间的联系<ul><li>供应关系（工厂，产品，用户）</li></ul></li><li>单个实体集内部的联系<ul><li>围棋比赛（黑方（选手甲），白方（选手乙））</li><li>选手甲和选手乙都是同一个实体集<strong>运动员</strong>中的实体</li></ul></li></ul></li><li>相同实体集之间的多种联系<ul><li>在同一组实体集之间可以存在多种联系</li><li>例如：<ul><li>职工之间<ul><li>管理关系（上下级关系）</li><li>同事关系</li></ul></li><li>教师与研究生之间<ul><li>教学关系</li><li>指导关系</li></ul></li></ul></li></ul></li><li>联系的函数对应关系<ul><li>一一对应（1 : 1）</li><li>一多对应（1 : m）或 多一对应（m : 1）</li><li>多多对应（m : n）</li></ul></li><li>联系所具有的特性<ul><li>因联系的发生而产生的特性可以通过联系上的<strong>属性</strong>来表示</li><li>例如：<ul><li>学习关系（学生，课程，<strong>成绩</strong>）</li><li>借阅关系（学生，图书，<strong>借阅日期</strong>，<strong>归还日期</strong>）</li><li>比赛（甲方，乙方，<strong>比赛结果</strong>）</li></ul></li></ul></li></ul></li></ul><h4 id="3-基本概念之间的连接关系"><a href="#3-基本概念之间的连接关系" class="headerlink" title="3. 基本概念之间的连接关系"></a>3. 基本概念之间的连接关系</h4><ul><li><p>实体（集）、属性及其连接关系的描述</p><ul><li>属性的描述：属性名，属性域</li><li>实体的描述：<ul><li>实体名</li><li>实体型：实体名 + 一组属性名<ul><li>用于描述实体的组成结构信息</li></ul></li><li>实体值<ul><li>实体中的每个属性都可以取值，由一个实体的所有属性的取值所构成的属性值的集合被称为该实体的实体值</li><li>在关系模型中，<strong>实体值</strong>又被称为<strong>元组</strong>（tuple）</li></ul></li><li>实体集的描述<ul><li>由具有相同实体型的实体所构成的集合被称为实体集</li><li>实体集的描述：属性集合 + 关键字（key）</li></ul></li></ul></li></ul></li><li><p>联系及其与实体集之间的连接关系的描述</p><ul><li>联系名：每个联系有一个名字</li><li>属性：联系也可以有属性<ul><li>由一个<strong>联系名</strong> + 与该联系相关的<strong>实体集的名称</strong>，以及<strong>联系上的属性</strong>，从而构成联系及其与实体集之间的连接关系的描述</li></ul></li><li>函数对应关系</li></ul></li></ul><h4 id="4-E-R-模型的图示法：E-R-图"><a href="#4-E-R-模型的图示法：E-R-图" class="headerlink" title="4. E-R 模型的图示法：E-R 图"></a>4. E-R 模型的图示法：E-R 图</h4><ul><li><p>使用一些简单的图形符号来表示概念数据模型</p></li><li><p>基本概念的表示</p>  <div align=center><img src="/img/posts/DB-2-3.jpg" title="基本概念的表示" height="50%" width="50%" /></div></li><li><p>连接关系的表示</p><ul><li><p>实体集与属性间的连接关系</p><ul><li>实体集： student</li><li>属性：<ul><li>S<sup>#</sup>（学号）</li><li>Sn（学生姓名）</li><li>Sa（学生年龄）      <div align=center><img src="/img/posts/DB-2-4.jpg" title="E-R图表示法" height="50%" width="50%" /></div></li></ul></li></ul></li><li><p>联系与属性的连接关系</p><ul><li>联系：SC</li><li>属性：G（学生的课程成绩）      <div align=center><img src="/img/posts/DB-2-5.jpg" title="E-R图表示法" height="50%" width="50%" /></div></li></ul></li><li><p>每个实体集（联系）可以有多个属性，但每个属性只能隶属于一个实体集（联系）</p></li><li><p>实体集与联系间的连接关系E-R图</p><ul><li>实体集student与联系SC</li><li>实体集course与联系SC      <div align=center><img src="/img/posts/DB-2-6.jpg" title="E-R图表示法" height="50%" width="50%" /></div></li></ul></li><li><p>每个联系可以与一个或多个实体集相关，每个实体集也可以与一个或多个联系相关</p>  <div align=center><img src="/img/posts/DB-2-7.jpg" title="E-R图表示法" height="50%" width="50%" /></div></li></ul></li><li><p>例：下图给出了一个工厂的物资管理E-R图，它由职工（employee），仓库（warehouse），项目（project），零件（part），供应商（supplier）等五个实体集以及供应、库存、领导、工作等四个联系所组成。</p></li></ul><p><img src="/img/posts/DB-2-8.jpg" alt="这是图片" title="某工厂物资管理E-R图"></p><h3 id="（二）扩充的E-R模型（EE-R模型）"><a href="#（二）扩充的E-R模型（EE-R模型）" class="headerlink" title="（二）扩充的E-R模型（EE-R模型）"></a>（二）扩充的E-R模型（EE-R模型）</h3><h4 id="1-IS-A联系"><a href="#1-IS-A联系" class="headerlink" title="1. IS-A联系"></a>1. IS-A联系</h4><ul><li><p>如果实体集 B 是实体集 A 的一个子集，且具有比实体集 A 更多的属性，则我们称在实体集 A 与实体集 B 之间存在着一种特殊的<strong>IS-A 联系</strong>。其中</p><ul><li>实体集 A 被称为实体集 B 的<strong>超（实体）集</strong></li><li>实体集 B 被称为实体集 A 的<strong>子（实体）集</strong></li></ul> <div align=center><img src="/img/posts/DB-2-9.jpg" title="超集和子集" height="50%" width="50%" /></div></li><li><p>子集 B 可以通过IS-A联系<strong>继承</strong>超集A中的所有属性</p></li></ul><h4 id="2-EE-R图"><a href="#2-EE-R图" class="headerlink" title="2. EE-R图"></a>2. EE-R图</h4><ul><li>IS-A联系的表示方法</li><li>例：用EE-R图表示大学、校长、职工间的概念模型。</li></ul><p><img src="/img/posts/DB-2-10.jpg" alt="这是图片" title="EE-R图"></p><ul><li>弱实体（Weak Entity）<ul><li><p>如果一个实体 A 的存在需要依赖于其他实体集中的某个实体的存在，那么实体 A 被称为弱实体。例如：</p><ul><li>职工 vs 家属</li><li>学生 vs 家长</li></ul></li><li><p>弱实体（集）与所依赖的实体（集）之间的函数对应关系应该是<strong>多对一</strong>的关系</p></li><li><p>弱实体的表示</p><ul><li>从弱实体到联系的有向箭头</li></ul> <div align=center><img src="/img/posts/DB-2-11.jpg" title="弱实体的表示" height="50%" width="50%" /></div></li><li><p>弱实体的例子</p><ul><li>订单、订单项与所订购的商品之间的EE-R图</li></ul></li></ul></li></ul><p><img src="/img/posts/DB-2-12.jpg" alt="这是图片" title="订单、订单项与所订购的商品之间的EE-R图"></p><h2 id="四、信息世界与逻辑模型"><a href="#四、信息世界与逻辑模型" class="headerlink" title="四、信息世界与逻辑模型"></a>四、信息世界与逻辑模型</h2><h3 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h3><ul><li>概念模型与逻辑模型对应关系表</li></ul><!-- TABLE ppt137--><table>    <tr>        <th align="center">概念模型</th>         <td align="center" colspan="3">E-R模型</td>           <td align="center">EE-R模型</td>         <td align="center">面向对象模型</td>         <td align="center">谓词模型</td>     </tr>    <tr>        <th align="center">逻辑模型</th>         <td align="center">层次模型</td>         <td align="center">网状模型</td>         <td align="center">关系模型</td>        <td align="center">对象关系模型</td>        <td align="center">面向对象模型</td>         <td align="center">谓词模型</td>              </tr></table><h3 id="（二）关系模型与关系模型数据库系统"><a href="#（二）关系模型与关系模型数据库系统" class="headerlink" title="（二）关系模型与关系模型数据库系统"></a>（二）关系模型与关系模型数据库系统</h3><h4 id="1-关系模型（Relational-model）"><a href="#1-关系模型（Relational-model）" class="headerlink" title="1. 关系模型（Relational model）"></a>1. 关系模型（Relational model）</h4><ul><li>关系模型的基本数据结构<ul><li>二维表，简称<strong>表</strong>（Table）</li></ul></li><li>关系模型的数据操纵<ul><li>是建立在二维表上的操作，它包括对一张表及多张表间的查询，以及对一张表的删除，插入及修改等操作</li></ul></li></ul><h4 id="2-二维表（Table）"><a href="#2-二维表（Table）" class="headerlink" title="2. 二维表（Table）"></a>2. 二维表（Table）</h4><ul><li>二维表由表框架与元组所组成，表框架由若干个属性组成</li><li>存放于框架内的每<strong>一行数据</strong>都被称为<strong>一个元组</strong>（Tuple）或称<strong>行</strong>（Row）</li><li>一张二维表是由一个有 n 个属性的框架及 m 个元组组成</li></ul><h4 id="3-关系"><a href="#3-关系" class="headerlink" title="3. 关系"></a>3. 关系</h4><ul><li>由行和列组成的二维表格</li><li>关系的约束<ul><li>同一表中的属性名各不相同</li><li>表中的属性与属性的排放次序无关</li><li>表中的元组均不相同</li><li>表中的元组与元组的排列次序无关</li><li>表中的每一分量必须是一个不可分割的基本数据项</li></ul></li></ul><h4 id="4-关系中的基本概念"><a href="#4-关系中的基本概念" class="headerlink" title="4. 关系中的基本概念"></a>4. 关系中的基本概念</h4><ul><li>关系模式<ul><li>一个关系的关系名及其属性名的集合构成该关系的关系模式</li></ul></li><li>关系数据库模式<ul><li>该关系数据库中所有关系的关系模式的集合</li></ul></li><li>元组<ul><li>关系中的每一行</li></ul></li><li>关键字（或简称为<strong>键</strong>-key）<ul><li>关系中的一个属性集的值能唯一标识关系中的一个元组，且又不含多余的属性值，则称该属性集为该关系的关键字</li><li>每一个关系都有关键字</li><li>一个关系也可以有多个关键字，所以关键字也被称为<strong>候选关键字</strong><ul><li>主关键字<ul><li>可以从关系的候选关键字中选取一个作为该关系的主关键字</li></ul></li><li>外关键字<ul><li>设关系 R 中的属性集 F 其取值来自于关系 S 中的主关键字 K 则称属性集 F 是关系 R 的外关键字</li><li>关系 R 和关系 S 可以是同一个关系</li></ul></li></ul></li></ul></li></ul><h4 id="5-关系模型上的数据操作"><a href="#5-关系模型上的数据操作" class="headerlink" title="5. 关系模型上的数据操作"></a>5. 关系模型上的数据操作</h4><ul><li>关系模型数据操作的对象是<strong>关系</strong></li><li>关系模型数据操作的结果也是一个<strong>关系</strong></li><li>关系模型的五种基本操作：<ul><li>属性指定</li><li>元组选择</li><li>关系的合并</li><li>元组插入</li><li>元组删除</li></ul></li></ul><h2 id="五、计算机世界与物理模型"><a href="#五、计算机世界与物理模型" class="headerlink" title="五、计算机世界与物理模型"></a>五、计算机世界与物理模型</h2><h4 id="1-物理模型"><a href="#1-物理模型" class="headerlink" title="1. 物理模型"></a>1. 物理模型</h4><ul><li>物理模型是面向计算机的模型，它构作数据库系统的物理实现<ul><li>主要涉及操作系统级文件组织，有时还会涉及到硬件级数据组织</li></ul></li></ul><h4 id="2-文件系统的组成"><a href="#2-文件系统的组成" class="headerlink" title="2. 文件系统的组成"></a>2. 文件系统的组成</h4><ul><li>项（Item）<ul><li>文件系统中最小基本单位，项内符号是不能继续分割的</li></ul></li><li>记录（Record）<ul><li>由若干项组成，记录内的各项间有内在语义联系</li><li>记录有型与值的区别</li></ul></li><li>文件（file）<ul><li>记录的集合</li><li>一般来说，一个文件所包含的记录都是同型的</li></ul></li><li>文件集（file set）<ul><li>由若干个文件构成</li></ul></li></ul><h4 id="3-提高文件读写操作效率的方法"><a href="#3-提高文件读写操作效率的方法" class="headerlink" title="3. 提高文件读写操作效率的方法"></a>3. 提高文件读写操作效率的方法</h4><ul><li>索引（Index）<ul><li>将文件中的记录与其物理地址（即磁盘块）间建立一张对应关系表以便于快速查找，这就是索引</li><li>索引一般也是一个文件。当数据文件中的记录数很大时，索引文件本身也还需要建立索引，这叫二级索引</li><li>依此类推，可以建立多级索引</li></ul></li><li>Hash法<ul><li>一种函数转换法，其主要思想是：通过一个hash函数将要查找的记录转换成该记录所在的物理地址，然后可以直接进行记录的定位读取操作</li></ul></li><li>集簇（Cluster）<ul><li>在记录查找中往往需要按某项的项值查找，将具有相同或相邻项值的记录聚集在相同磁盘块内或圆柱体内以减少读盘次数，提高查找速度，这被称为集簇</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库概论一：数据库系统概述</title>
    <link href="/2022/09/09/database_note_1/"/>
    <url>/2022/09/09/database_note_1/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="（一）数据（Data）"><a href="#（一）数据（Data）" class="headerlink" title="（一）数据（Data）"></a>（一）数据（Data）</h3><ol><li>信息与数据</li></ol><ul><li>信息<ul><li>用于反映现实世界中事物的物理状态，向人们提供一些已知的、客观存在的事实和知识</li></ul></li><li>数据<ul><li>是指具有一定的语义含义，并且可以被记录下来的已知事实</li><li>在计算机中，数据被表示为<strong>具有一定格式（或结构）的符号串</strong> ，它是计算机软件中程序加工的原料与结果，属于软件范畴</li></ul></li><li>数据是信息的载体，信息则是数据的内涵</li></ul><ol start="2"><li>数据的特性</li></ol><ul><li>数据表现的多样性：常用数据、多媒体数据、抽象数据</li><li>数据的可构造性<ul><li>型（type)：数据类型（type)、数据结构（structure)、数据模式（schema) </li><li>值（value)</li></ul></li><li>数据的挥发性与持久性</li><li>数据的私有性与共享性</li><li>数据“量”的表示：少量、大量、海量</li></ul><ol start="3"><li>数据特性的变化</li></ol><ul><li>数据的量：少量$\to$大量$\to$海量（big data)</li><li>数据的结构：简单$\to$复杂</li><li>数据的服务范围：私有$\to$共享</li><li>数据在软件中的地位：附属地位（以程序为主体）$\to$主导地位（以数据为中心）</li></ul><p><img src="/img/posts/DB-1-1.jpg" alt="这是图片" title="以数据为主体的软件系统示意图"></p><h3 id="（二）数据库（Database，简称DB）"><a href="#（二）数据库（Database，简称DB）" class="headerlink" title="（二）数据库（Database，简称DB）"></a>（二）数据库（Database，简称DB）</h3><ol><li><p>数据库是<strong>数据的集合</strong>，它具有统一的结构形式，存放于统一的存贮介质内，并由统一机构管理，它由多种应用数据集成，并可被应用所共享。</p></li><li><p>特点：结构化、集中存储、数据共享</p></li></ol><h3 id="（三）数据库管理系统（Database-Management-System，简称DBMS）"><a href="#（三）数据库管理系统（Database-Management-System，简称DBMS）" class="headerlink" title="（三）数据库管理系统（Database Management System，简称DBMS）"></a>（三）数据库管理系统（Database Management System，简称DBMS）</h3><ol><li>DBMS是一种管理数据库的系统软件  </li><li>DBMS是在文件管理系统的基础上发展起来的，它区别于其它计算机软件系统的特点在于：</li></ol><ul><li>能对持久性数据进行管理</li><li>能对大量数据进行有效存取</li><li>可为众多使用者提供同一数据（即数据共享）</li></ul><ol start="3"><li>DBMS的作用</li></ol><ul><li>是数据库的应用程序与数据库的接口</li><li>在保证数据安全、可靠的同时，提高数据库应用时的简明性和方便性</li></ul><ol start="4"><li>DBMS的功能</li></ol><ul><li>数据组织（Definition）<ul><li><strong>数据模式定义</strong>（为数据库构造数据框架）</li><li><strong>数据存取的物理操作</strong>（为数据模式构造有效的物理存取方法与手段）</li></ul></li><li>数据操纵（Manipulation）<ul><li>提供数据查询、插入、修改及删除的功能</li><li>还具有简单算术运算及统计等能力</li><li>此外，它还可以与某些过程性语言结合，进行过程性操作</li></ul></li><li>数据维护<ul><li><strong>数据的完整性、安全性定义与检查</strong></li></ul></li><li>数据控制及保护<ul><li><strong>数据库的并发控制与故障恢复</strong></li></ul></li><li>数据交换</li><li>数据服务<ul><li>内置函数</li><li>拷贝、转储、重组、性能监测、分析</li></ul></li><li>数据字典</li></ul><ol start="5"><li>数据子语言（data sub_language）</li></ol><ul><li>数据定义语言（Data Definition Language，简称DDL）<ul><li>负责数据的模式定义与数据的物理存取构作</li></ul></li><li>数据操纵语言（Data Manipulation Language，简称DML）<ul><li>负责数据的操纵，包括查询及增、删、改等操作</li></ul></li><li>数据控制语言（Data Control Language，简称DCL）<ul><li>负责数据的完整性、安全性的定义与检查以及并发控制、故障恢复等功能</li></ul></li></ul><ol start="6"><li>数据子语言的使用方式</li></ol><ul><li>交互式命令语言<ul><li>能在终端上即席操作，又被称为自含型或自主型语言</li></ul></li><li>宿主型语言<ul><li>需要嵌入到某种<strong>宿主语言</strong>中</li><li>宿主语言：一种高级程序设计语言，比如FORTRAN，C&#x2F;C++，JAVA，Python等</li></ul></li></ul><h3 id="（四）数据库管理员（Database-Administrator，简称DBA）"><a href="#（四）数据库管理员（Database-Administrator，简称DBA）" class="headerlink" title="（四）数据库管理员（Database Administrator，简称DBA）"></a>（四）数据库管理员（Database Administrator，简称DBA）</h3><ol><li>DBA是对数据库进行规划、设计、维护、监视的专职人员</li><li>DBA的主要工作</li></ol><ul><li>数据库设计，建立与调整</li><li>数据库维护</li><li>改善系统性能，提高系统效率</li></ul><h3 id="（五）数据库系统（Database-System，简称DBS）"><a href="#（五）数据库系统（Database-System，简称DBS）" class="headerlink" title="（五）数据库系统（Database System，简称DBS）"></a>（五）数据库系统（Database System，简称DBS）</h3><ol><li>DBS是一个以对海量的、具有复杂数据结构的、可以持久保存的、可供多用户共享的数据进行统一管理为目标的计算机系统</li><li>DBS的组成部分</li></ol><ul><li>数据库</li><li>数据库管理系统</li><li>数据库管理员</li><li>软件平台<ul><li>操作系统，语言，数据库应用开发工具，通用的数据库访问接口</li></ul></li><li>硬件平台</li></ul><h3 id="（六）数据库应用系统（Database-Application-System，简称DBAS）"><a href="#（六）数据库应用系统（Database-Application-System，简称DBAS）" class="headerlink" title="（六）数据库应用系统（Database Application System，简称DBAS）"></a>（六）数据库应用系统（Database Application System，简称DBAS）</h3><ol><li>DBAS是利用数据库系统作<strong>应用开发</strong>所构成的集成化的独立运行系统</li><li>DBAS的组成</li></ol><ul><li>数据库系统</li><li>应用软件</li><li>应用界面</li><li>用户</li></ul><p><img src="/img/posts/DB-1-2.jpg" alt="这是图片" title="数据库应用系统层次结构示意图"></p><h3 id="（七）数据库用户（Database-Users）"><a href="#（七）数据库用户（Database-Users）" class="headerlink" title="（七）数据库用户（Database Users）"></a>（七）数据库用户（Database Users）</h3><ol><li>最终用户（End users）</li></ol><ul><li>终端查询用户（Casual users）</li><li>应用程序的使用者（Naive users）</li></ul><ol start="2"><li>应用程序开发人员（Application programmers）</li><li>数据库管理员</li></ol><p><img src="/img/posts/DB-1-3.jpg" alt="这是图片" title="用户与数据库系统之间的网络结构示意图"></p><h2 id="二、数据库系统的发展历史"><a href="#二、数据库系统的发展历史" class="headerlink" title="二、数据库系统的发展历史"></a>二、数据库系统的发展历史</h2><p><img src="/img/posts/DB-1-4.jpg" alt="这是图片" title="数据库系统发展简图"></p><h4 id="1-文件系统阶段"><a href="#1-文件系统阶段" class="headerlink" title="1. 文件系统阶段"></a>1. 文件系统阶段</h4><ul><li>文件系统是数据库系统发展的初级阶段，出现于20世纪50年代末期</li><li>目前一般将其看成仅是<strong>数据库系统的雏形</strong>，而不是真正的数据库系统</li><li>优点<ul><li>利用文件系统来参与数据管理，向用户提供简单的数据管理和共享能力</li></ul></li><li>缺点<ul><li>无法提供完整统一的数据管理功能和较强的数据共享能力</li><li>文件系统只是操作系统的一个附属软件，因此也不利于数据库系统在不同平台之间的移植</li></ul></li></ul><h4 id="2-层次数据库与网状数据库"><a href="#2-层次数据库与网状数据库" class="headerlink" title="2. 层次数据库与网状数据库"></a>2. 层次数据库与网状数据库</h4><ul><li>层次数据库与网状数据库于20世纪60年代末开始发展</li><li>它们为统一管理与共享数据提供了有力支撑，<strong>是真正的数据库系统</strong></li><li>优点<ul><li>数据库系统为用户提供了统一的数据管理工具，向用户提供了数据共享能力</li></ul></li><li>缺点<ul><li>它们脱胎于文件系统，<strong>受文件的物理影响较大</strong>，对数据库的使用带来不便</li><li><strong>数据模式构造烦琐</strong>，不利于推广使用</li></ul></li></ul><h4 id="3-关系数据库"><a href="#3-关系数据库" class="headerlink" title="3. 关系数据库"></a>3. 关系数据库</h4><ul><li>关系数据库于20世纪70年代开始问世，80年代初进入潮流</li><li>优点<ul><li>结构简单、使用方便、逻辑性强、物理性少</li></ul></li><li>缺点<ul><li>模型的描述能力不足</li><li>数据操纵功能有待进一步的扩展</li></ul></li></ul><h4 id="4-通用数据库系统"><a href="#4-通用数据库系统" class="headerlink" title="4. 通用数据库系统"></a>4. 通用数据库系统</h4><ul><li>20世纪90年代的研究与发展重点集中于具有通用性的三类数据库系统<ul><li>面向对象数据库系统</li><li>知识库系统</li><li>关系数据库系统扩充</li></ul></li></ul><h4 id="5-新一代数据库系统"><a href="#5-新一代数据库系统" class="headerlink" title="5. 新一代数据库系统"></a>5. 新一代数据库系统</h4><ul><li>进入21世纪，数据库技术的发展集中于对传统<strong>关系数据库系统</strong>的进一步扩充与改造上<ul><li>对象关系数据库系统</li><li>数据仓库（Data Warehouse）</li><li>Web数据库</li><li>安全数据库</li><li>嵌入式数据库，移动数据库，实时数据库，网格数据库，传感器网络数据库……</li></ul></li></ul><h2 id="三、数据库系统的基本特点"><a href="#三、数据库系统的基本特点" class="headerlink" title="三、数据库系统的基本特点"></a>三、数据库系统的基本特点</h2><h4 id="1-数据的集成性（integration）"><a href="#1-数据的集成性（integration）" class="headerlink" title="1. 数据的集成性（integration）"></a>1. 数据的集成性（integration）</h4><ul><li>集多种应用数据于一体</li><li>集成性的表现<ul><li>采用统一的数据结构</li><li>建立一个全局统一的数据模式</li><li>根据每个应用的数据需要构造局部模式</li></ul></li></ul><h4 id="2-数据的高共享性与低冗余性"><a href="#2-数据的高共享性与低冗余性" class="headerlink" title="2. 数据的高共享性与低冗余性"></a>2. 数据的高共享性与低冗余性</h4><ul><li>数据共享<ul><li>可供多个应用程序使用，并可用于不同的目的</li><li>可以在已有的数据库系统上开发新的应用程序</li><li>可向外界提供信息服务功能</li></ul></li><li>数据冗余<ul><li>同一个数据在不同的地方出现了重复存储</li></ul></li><li>数据库系统所具有的高共享性和低冗余性不仅可以减少不必要的存储空间，更为重要的是可以避免<strong>数据的不一致性</strong></li><li>数据的一致性<ul><li>在系统中，同一数据的不同出现应保持相同的值</li></ul></li><li>数据的不一致性<ul><li>同一数据在系统的不同拷贝处有不同的值</li><li>数据的不一致性会造成系统的混乱，因此减少冗余性、避免数据的不同出现是保证系统一致性的基础</li></ul></li></ul><h4 id="3-数据独立性"><a href="#3-数据独立性" class="headerlink" title="3. 数据独立性"></a>3. 数据独立性</h4><ul><li>指数据库中的数据与使用这些数据的应用程序之间的互不依赖性</li><li>即数据或数据结构的改变不会导致对使用这些数据的应用程序的修改，反之亦然<ul><li>物理独立性<ul><li>数据的物理结构（包括存储结构、存取方式等）的改变，不影响数据库的逻辑结构，从而不致引起应用程序的变化</li></ul></li><li>逻辑独立性<ul><li>数据库总体逻辑结构的改变，如修改数据模式、增加新的数据类型、改变数据间联系等，不需要相应修改应用程序</li></ul></li></ul></li></ul><h4 id="4-数据的统一管理与控制"><a href="#4-数据的统一管理与控制" class="headerlink" title="4. 数据的统一管理与控制"></a>4. 数据的统一管理与控制</h4><ul><li>数据的完整性检查<ul><li>对数据库中数据正确性作检查以保证数据的正确</li></ul></li><li>数据的安全性保护<ul><li>对数据库访问者作检查以防止非法访问</li></ul></li><li>并发控制<ul><li>对多个应用并发访问所产生的相互干扰作控制以保证其正确性</li></ul></li><li>数据库故障恢复<ul><li>对遭受破坏的数据具有恢复能力，使数据库具有抗破坏性</li></ul></li></ul><h2 id="四、数据库内部结构体系"><a href="#四、数据库内部结构体系" class="headerlink" title="四、数据库内部结构体系"></a>四、数据库内部结构体系</h2><h3 id="（一）数据库系统的三级模式"><a href="#（一）数据库系统的三级模式" class="headerlink" title="（一）数据库系统的三级模式"></a>（一）数据库系统的三级模式</h3><p><img src="/img/posts/DB-1-5.jpg" alt="这是图片" title="三级模式两种映射关系图"></p><h4 id="1-概念模式"><a href="#1-概念模式" class="headerlink" title="1. 概念模式"></a>1. 概念模式</h4><ul><li>是关于整个数据库中数据的全局逻辑结构的描述</li><li>是面向数据库系统的，它一般以某种数据模型为基础，利用具体的DBMS所提供的数据定义语言（DDL）来描述<ul><li>数据的类型、长度、特征</li><li>数据间的联系</li><li>安全性、完整性等方面的要求</li></ul></li></ul><h4 id="2-外模式（子模式、用户模式）"><a href="#2-外模式（子模式、用户模式）" class="headerlink" title="2. 外模式（子模式、用户模式）"></a>2. 外模式（子模式、用户模式）</h4><ul><li>是关于某个用户所需数据的逻辑结构的描述</li><li>外模式可由概念模式推导而出，是概念模式的一个子集<ul><li>一个概念模式可对应着多个外模式</li><li>一个用户只关心并通过与其相关的外模式来使用数据库，其有利之处在于<ul><li>简化用户接口，便于使用</li><li>降低数据冗余度</li><li>有利于数据的安全性保护和保密</li></ul></li></ul></li></ul><h4 id="3-内模式（物理模式）"><a href="#3-内模式（物理模式）" class="headerlink" title="3. 内模式（物理模式）"></a>3. 内模式（物理模式）</h4><ul><li>是关于数据库中数据的物理存储结构和物理存取方法的描述</li></ul><h4 id="4-三种模式对应三个层次上的数据库概念"><a href="#4-三种模式对应三个层次上的数据库概念" class="headerlink" title="4. 三种模式对应三个层次上的数据库概念"></a>4. 三种模式对应三个层次上的数据库概念</h4><ul><li>概念数据库</li><li>用户数据库</li><li>物理数据库</li></ul><p>在这三种数据库中，只有<strong>物理数据库</strong>是真实存在于计算机的外存中的，其他两种数据库并不真正存在于计算机中，而是由物理数据库通过数据库管理系统构造而成的</p><h3 id="（二）数据库系统的两级映射"><a href="#（二）数据库系统的两级映射" class="headerlink" title="（二）数据库系统的两级映射"></a>（二）数据库系统的两级映射</h3><h4 id="1-概念模式到内模式的映射"><a href="#1-概念模式到内模式的映射" class="headerlink" title="1. 概念模式到内模式的映射"></a>1. 概念模式到内模式的映射</h4><ul><li>该映射给出了概念模式中数据的<strong>全局逻辑结构</strong>到数据的<strong>物理存储结构</strong>间的对应关系，此种映射一般由DBMS实现<ul><li>可实现<strong>物理独立性</strong></li></ul></li></ul><h4 id="2-外模式到概念模式的映射"><a href="#2-外模式到概念模式的映射" class="headerlink" title="2. 外模式到概念模式的映射"></a>2. 外模式到概念模式的映射</h4><ul><li>概念模式是一个全局模式，而外模式则是用户的局部模式。一个概念模式中可以定义多个外模式，而每个外模式是概念模式的一个基本<strong>视图</strong></li><li>外模式到概念模式的映射给出了外模式与概念模式的对应关系，这种映射一般也由DBMS实现<ul><li>可实现<strong>逻辑独立性</strong></li></ul></li></ul><h4 id="3-数据库系统的两级映射"><a href="#3-数据库系统的两级映射" class="headerlink" title="3. 数据库系统的两级映射"></a>3. 数据库系统的两级映射</h4><ul><li>数据库系统通过两级映射建立三级模式间的<strong>联系与转换</strong>，使得概念模式与外模式虽然在物理上并不存在，但也能通过映射而获得其存在的实体</li><li>三级模式之间的两级映射也保证了数据库系统中<strong>数据独立性</strong>的实现，亦即数据的内模式或概念模式的改变，并不影响用户使用到的外模式，只要调整它们之间的映射方式即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级程序设计一：数据抽象——对象与类</title>
    <link href="/2022/09/07/AP1/"/>
    <url>/2022/09/07/AP1/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据抽象与封装概述"><a href="#一、数据抽象与封装概述" class="headerlink" title="一、数据抽象与封装概述"></a>一、数据抽象与封装概述</h2><h3 id="（一）抽象与封装"><a href="#（一）抽象与封装" class="headerlink" title="（一）抽象与封装"></a>（一）抽象与封装</h3><ol><li><p>抽象与封装是两个重要的程序设计手段，主要是用来驾驭程序的复杂度，便于<strong>大型程序</strong>的设计、理解与维护。</p></li><li><p>对于一个程序实体而言，</p></li></ol><ul><li><strong>抽象</strong>是指该程序实体的外部可观察到的行为，不考虑该程序实体的内部是如何实现的。（控制复杂度）</li><li><strong>封装</strong>是指把该程序实体内部的具体实现细节对使用者隐藏起来，只对外提供一个接口。（信息保护）</li></ul><ol start="3"><li>主要的程序抽象与封装机制包括：</li></ol><ul><li>过程抽象与封装</li><li>数据抽象与封装</li></ul><h3 id="（二）过程抽象与封装"><a href="#（二）过程抽象与封装" class="headerlink" title="（二）过程抽象与封装"></a>（二）过程抽象与封装</h3><ol><li><strong>过程抽象</strong></li></ol><ul><li>用一个名字来代表一段完成一定功能的程序代码，代码的使用者只需要知道代码的名字以及相应的功能，而不需要知道对应的程序代码是如何实现的。</li></ul><ol start="2"><li><strong>过程封装</strong></li></ol><ul><li>把命名代码的具体实现隐藏起来（对使用者不可见，或不可直接访问），使用者只能通过代码名字来使用相应的代码。</li><li>命名代码所需要的数据是通过参数（或全局变量）来获得，计算结果通过返回值机制（或全局变量）返回。</li></ul><ol start="3"><li><p>实现过程抽象与封装的程序实体通常称为<strong>子程序</strong>。在C&#x2F;C++语言中，子程序用<strong>函数</strong>来表示。</p></li><li><p>过程抽象与封装是基于功能分解与复合的<strong>过程式程序设计</strong>的基础。</p></li></ol><ul><li>过程实现了抽象与封装</li><li>数据是公开的，缺乏保护</li></ul><p><img src="/img/posts/AP-1-1.png" alt="这是图片" title="过程抽象与封装"></p><h3 id="（三）数据抽象与封装"><a href="#（三）数据抽象与封装" class="headerlink" title="（三）数据抽象与封装"></a>（三）数据抽象与封装</h3><ol><li><strong>数据抽象</strong></li></ol><ul><li>只描述对数据能实施哪些<strong>操作</strong>以及这些<strong>操作之间的关系</strong>，数据的使用者不需要知道数据的具体表示形式。</li></ul><ol start="2"><li><strong>数据封装</strong></li></ol><ul><li>把数据及其操作作为一个<strong>整体（封装体）</strong>来进行实现，其中，数据的<strong>具体表示</strong> 被隐藏起来（使用者<strong>不可见</strong>，或不可直接访问），对数据的访问（使用）只能通过封装体对外<strong>接口</strong>提供的操作来完成。</li></ul><ol start="3"><li>与过程抽象与封装相比，数据抽象与封装能够实现更好的数据保护。</li><li>数据抽象与封装是<strong>面向对象程序设计</strong>的基础，其中的<strong>对象</strong>体现了数据抽象与封装。</li></ol><p><img src="/img/posts/AP-1-2.png" alt="这是图片" title="数据抽象与封装"></p><h3 id="（四）例：“栈”数据的表示与操作"><a href="#（四）例：“栈”数据的表示与操作" class="headerlink" title="（四）例：“栈”数据的表示与操作"></a>（四）例：“栈”数据的表示与操作</h3><ol><li><strong>栈</strong>是一种由若干个具有线性次序关系的元素所构成的复合数据。  对栈只能实施两种操作：</li></ol><ul><li><strong>进栈（push）</strong>：往栈中增加一个元素</li><li><strong>退栈（pop）</strong>：从栈中删除一个元素</li><li>上述两个操作满足一个重要性质：<ul><li><code>push(...); ...pop(...); ... ;push(x);pop(y);</code></li><li><code>x == y</code></li></ul></li><li>即，增加&#x2F;删除操作在线性序列的同一端进行（<strong>后进先出</strong>，Last In First Out，简称LIFO）<br>从数据抽象的角度，栈的使用者只需要知道上面的这些信息，不需要知道栈是如何实现的（数组或链表等）。</li></ul><ol start="2"><li>“栈”的实现————非数据抽象和封装途径</li></ol><ul><li>定义一个数据类型来表示栈数据  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> STACK_SIZE=<span class="hljs-number">100</span>;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span>  <br>&#123;<br><span class="hljs-type">int</span> top;  <br><span class="hljs-type">int</span> buffer[STACK_SIZE];  <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/img/posts/AP-1-3.png" alt="这是图片" title="栈"></p><ul><li><p>直接操作栈数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Stack st; <span class="hljs-comment">//定义栈数据</span><br>st.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">//对st进行初始化</span><br><span class="hljs-comment">//把12放进栈</span><br><span class="hljs-keyword">if</span> (st.top == STACK_SIZE<span class="hljs-number">-1</span>)   <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Stack is overflow.\n&quot;</span>; <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <br>&#125;<br>st.top++; <br>st.buffer[st.top] = <span class="hljs-number">12</span>; <br>......<br><span class="hljs-comment">//把栈顶元素退栈并存入变量x</span><br><span class="hljs-keyword">if</span> (st.top == <span class="hljs-number">-1</span>)    <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Stack is empty.\n&quot;</span>; <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">int</span> x = st.buffer[st.top]; <br>st.top--;<br></code></pre></td></tr></table></figure><ul><li>存在的问题  <ul><li>操作必须知道数据的具体表示形式。</li><li>数据表示形式发生变化将会影响操作。</li><li>麻烦并易产生误操作，因此不安全。例如，把进栈操作误写成： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">st.top--; <span class="hljs-comment">//书写失误导致误操作</span><br>st.buffer[st.top] = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure></li><li>忘了初始化： <code>st.top = -1;</code></li></ul></li></ul></li><li><p>通过过程抽象与封装操作栈数据</p><ul><li>先预定义三个函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Stack &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>s.top = <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack &amp;s, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (s.top == STACK_SIZE<span class="hljs-number">-1</span>) <br>&#123;<br>cout &lt;&lt; “Stack is overflow.\n”;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>s.top++; <br>s.buffer[s.top] = i;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack &amp;s, <span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (s.top == <span class="hljs-number">-1</span>) <br>&#123;<br>cout &lt;&lt;“Stack is empty.\n”;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>  <span class="hljs-keyword">else</span> <br>&#123;<br>i = s.buffer[s.top]; <br>s.top--;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>利用预定义的函数操作栈数据<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Stack st; <span class="hljs-comment">//定义栈数据</span><br><span class="hljs-type">int</span> x;<br><span class="hljs-built_in">init</span>(st);  <span class="hljs-comment">//对st进行初始化。</span><br><span class="hljs-built_in">push</span>(st,<span class="hljs-number">12</span>);  <span class="hljs-comment">//把12放进栈。</span><br>......<br><span class="hljs-built_in">pop</span>(st,x);  <span class="hljs-comment">//把栈顶元素退栈并存入变量x。</span><br></code></pre></td></tr></table></figure></li><li>存在的问题<ul><li>数据类型的定义与操作的定义是<strong>分开</strong>的，二者之间没有<strong>显式</strong>的联系，push、pop在<strong>形式</strong>上与下面的函数f没有区别，函数f也能作用于st： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Stack &amp;s)</span> </span>&#123; ...... &#125;<br><span class="hljs-built_in">f</span>(st); <span class="hljs-comment">//操作st之后，st可能不再是一个“栈”了！</span><br></code></pre></td></tr></table></figure></li><li>数据表示仍然是公开的，无法防止使用者直接操作栈数据，因此也会面临直接操作栈数据所带来的问题。例如，把进栈操作误写成：   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">st.top--; <br>st.buffer[st.top] = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure></li><li>忘了初始化：<code>init(st);</code></li></ul></li></ul></li></ul><ol start="3"><li>“栈”的实现————非数据抽象和封装途径</li></ol><ul><li>定义栈数据类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> STACK_SIZE=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123; <br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//对外的接口（外部可使用的内容）</span><br><span class="hljs-built_in">Stack</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span>;<br><span class="hljs-keyword">private</span>: <span class="hljs-comment">//隐藏的内容，外部不可使用</span><br><span class="hljs-type">int</span> top;<br><span class="hljs-type">int</span> buffer[STACK_SIZE];<br>&#125;;<br>Stack::<span class="hljs-built_in">Stack</span>()<br>&#123; <br>top = <span class="hljs-number">-1</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (top == STACK_SIZE<span class="hljs-number">-1</span>) <br>&#123;<br>cout &lt;&lt; “Stack is overflow.\n”;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>top++;  <br>buffer[top] = i;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>) <br>&#123;<br>cout &lt;&lt; “Stack is empty.\n”;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>i = buffer[top]; <br>top--;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用栈类型数据<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Stack st;  <span class="hljs-comment">//会自动地去调用st.Stack()对st进行初始化。</span><br><span class="hljs-type">int</span> x;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-number">12</span>);  <span class="hljs-comment">//把12放进栈st。</span><br>......<br>st.<span class="hljs-built_in">pop</span>(x);  <span class="hljs-comment">//把栈顶元素退栈并存入变量x。</span><br>......<br>st.top = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//Error</span><br>st.top++;  <span class="hljs-comment">//Error</span><br>st.buffer[st.top] = <span class="hljs-number">12</span>;  <span class="hljs-comment">//Error</span><br>st.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>“栈”的另一种实现（链表表示）————数据抽象和封装途径</li></ol><p><img src="/img/posts/AP-1-4.png" alt="这是图片" title="栈的链表表示"></p><ul><li>栈的数据表示发生变化！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Stack</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> content;<br>Node *next;<br>&#125; *top; <span class="hljs-comment">//数据表示了改成链表</span><br>&#125;;<br>Stack::<span class="hljs-built_in">Stack</span>()<br>&#123;<br>top = <span class="hljs-literal">NULL</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>Node *p=<span class="hljs-keyword">new</span> Node;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Stack is overflow.\n&quot;</span>;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>p-&gt;content = i;<br>p-&gt;next = top;top = p;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (top == <span class="hljs-literal">NULL</span>) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Stack is empty.\n&quot;</span>;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>Node *p=top;<br>top = top-&gt;next;<br>i = p-&gt;content;<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>改变栈的数据表示对使用者没有影响！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Stack st; <br><span class="hljs-type">int</span> x;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-number">12</span>);<br>st.<span class="hljs-built_in">pop</span>(x);<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、面向对象程序设计概述"><a href="#二、面向对象程序设计概述" class="headerlink" title="二、面向对象程序设计概述"></a>二、面向对象程序设计概述</h2><h3 id="（一）面向对象程序设计概念"><a href="#（一）面向对象程序设计概念" class="headerlink" title="（一）面向对象程序设计概念"></a>（一）面向对象程序设计概念</h3><ol><li><strong>面向对象程序设计</strong>（Object-oriented Programming）具有以下几个特征：</li></ol><ul><li>程序由若干<strong>对象</strong>组成，每个对象是由一些<strong>数据</strong>以及对这些数据所能实施的<strong>操作</strong>所构成的封装体；</li><li>对象的特征（包含那些数据与操作）由相应的<strong>类</strong>来描述；</li><li>对数据的操作是通过向包含数据的对象发送<strong>消息</strong>（调用对象类的对外接口中的操作）来实现的；</li><li>一个类所描述的对象特征可以从其它的类<strong>继承</strong>（获得）。<br><strong>注意</strong>：如果没有“继承”，则称为：<strong>基于对象的程序设计</strong>（Object-based Programming）</li></ul><ol start="2"><li>在面向&#x2F;基于对象的程序设计中，对象&#x2F;类体现了数据抽象与封装。</li><li>面向对象程序的构成：</li></ol><p><img src="/img/posts/AP-1-5.png" alt="这是图片" title="面向对象程序"></p><h3 id="（二）面向对象程序的执行过程"><a href="#（二）面向对象程序的执行过程" class="headerlink" title="（二）面向对象程序的执行过程"></a>（二）面向对象程序的执行过程</h3><ul><li>对象构成了面向对象程序的基本<strong>计算</strong>单位，程序的执行体现为：对象间的一系列<strong>消息传递</strong>：<ul><li>从程序外部向程序中的某个对象发送第一条消息启动计算过程；</li><li>该对象在处理这条消息的过程中，又向程序中的其它对象发送消息，从而引起进一步的计算；</li><li>消息处理可分为两种方式：<ul><li>同步消息处理：消息发送者必须等待消息处理完才能继续执行其它操作（顺序执行）</li><li>异步消息处理：消息发送者不必等待消息处理完就能继续执行其它操作（并发执行）</li></ul></li></ul></li></ul><h3 id="（三）面向对象程序设计的基本内容"><a href="#（三）面向对象程序设计的基本内容" class="headerlink" title="（三）面向对象程序设计的基本内容"></a>（三）面向对象程序设计的基本内容</h3><ol><li>对象&#x2F;类(Object&amp;Class)</li></ol><ul><li><strong>对象</strong>是由<strong>数据</strong>及能对其实施的<strong>操作</strong>所构成的封装体。</li><li><strong>类</strong>描述了对象的<strong>特征</strong>（包含什么类型的数据和哪些操作），实现抽象。</li><li>对象属于<strong>值</strong>的范畴，是程序运行时刻的实体；类则属于<strong>类型</strong>的范畴，属于编译时刻的实体。</li></ul><ol start="2"><li>继承(Inheritance)</li></ol><ul><li>在定义一个新的类（子类、<strong>派生类</strong>）时，可以把已有类（父类、<strong>基类</strong>）的一些特征描述先包含进来，然后再定义新的特征。</li><li><strong>单继承</strong>与<strong>多继承</strong></li></ul><ol start="3"><li>消息的多态与动态绑定</li></ol><ul><li><strong>多态</strong>(Polymorphism)：某一论域中的一个元素存在多种形式和解释。在程序中，多态通常体现为：<ul><li><strong>一名多用</strong>：<ul><li>函数名重载</li><li>操作符重载（语言预定义和用户自定义）</li></ul></li><li><strong>类属</strong>：<ul><li>类属函数：一个函数能对多种类型的数据进行操作。</li><li>类属类：一个类可以描述多种类型的对象。</li></ul></li><li>面向对象程序特有的多态（继承机制带来的）：<ul><li><strong>对象类型</strong>的多态：子类对象既属于子类，也属于父类。 </li><li><strong>对象标识</strong>的多态：父类的引用或指针可以引用或指向父类对象，也可以引用或指向子类对象。</li><li><strong>消息</strong>的多态：发给父类对象的消息也可以发给子类对象，父类与子类会给出不同的解释（处理）。</li></ul></li></ul></li><li><strong>绑定</strong>(Binding)：确定对多态元素的某个使用是多态元素的哪一种形式。可分为静态绑定和动态绑定。<ul><li><strong>静态绑定</strong>（Static Binding）：在编译时刻确定。</li><li><strong>动态绑定</strong>（Dynamic Binding）：在运行时刻确定。</li><li>大多数形式的多态可采用静态绑定。</li><li>由于存在对象标识的多态和消息的多态，<strong>消息有时要采用动态绑定</strong>！<ul><li>通过父类的引用或指针向对象发送消息</li></ul></li></ul></li><li>多态带来的好处<ul><li>使得程序功能扩充变得容易（程序上层代码不变，只要增加底层的具体实现即可）。</li><li>增强语言的可扩充性（如操作符重载等）。</li></ul></li></ul><h3 id="（四）面向对象程序设计带来的好处"><a href="#（四）面向对象程序设计带来的好处" class="headerlink" title="（四）面向对象程序设计带来的好处"></a>（四）面向对象程序设计带来的好处</h3><ol><li>一个方法的优劣主要看它是否能提高软件<strong>开发效率</strong>和保证<strong>软件质量</strong>。</li><li>影响软件开发效率和软件质量的因素主要包括：</li></ol><ul><li><strong>抽象</strong>（控制复杂度）</li><li><strong>封装</strong>（保护信息）</li><li><strong>模块化</strong>（组织和管理大型程序）</li><li><strong>软件复用</strong>（缩短开发周期）</li><li><strong>可维护性</strong>（延长软件寿命）</li><li><strong>软件模型的自然度</strong>（缩小解题空间与问题空间之间的语义间隙，实现从问题到解决方案的自然过渡）</li></ul><h3 id="（五）过程式程序设计的特点"><a href="#（五）过程式程序设计的特点" class="headerlink" title="（五）过程式程序设计的特点"></a>（五）过程式程序设计的特点</h3><ol><li>以功能为中心，强调过程（功能）抽象，但数据与操作分离，二者联系松散。</li><li>实现了操作的封装，但数据是公开的，数据缺乏保护。</li><li>按子程序划分模块，模块边界模糊。</li><li>子程序往往针对某个程序而设计，这使得程序难以复用。</li><li>功能易变，程序维护困难。</li><li>基于子程序的解题方式与问题空间缺乏对应。</li></ol><h3 id="（六）面向对象程序设计的特点"><a href="#（六）面向对象程序设计的特点" class="headerlink" title="（六）面向对象程序设计的特点"></a>（六）面向对象程序设计的特点</h3><ol><li>以数据为中心，强调数据抽象，操作依附于数据，二者联系紧密。</li><li>实现了数据的封装，加强了数据的保护。</li><li>按对象类划分模块，模块边界清晰。</li><li>对象类往往具有通用性，再加上继承机制，使得程序容易复用。</li><li>对象类相对稳定，有利于程序维护。</li><li>基于对象交互的解题方式与问题空间有很好的对应。</li></ol><h2 id="三、对象与类"><a href="#三、对象与类" class="headerlink" title="三、对象与类"></a>三、对象与类</h2><h3 id="（一）类"><a href="#（一）类" class="headerlink" title="（一）类"></a>（一）类</h3><h4 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h4><ul><li><strong>对象</strong>构成了面向对象程序的基本计算单位，而对象的特征则由相应的<strong>类</strong>来描述。  </li><li>对象是用类来创建的，因此，程序中首先要定义类。</li><li>C++的类是一种用户自定义类型，定义形式如下：<br> <code>class &lt;类名&gt; &#123; &lt;成员描述&gt; &#125; ;</code><ul><li>成员包括：<strong>数据成员</strong>和<strong>成员函数</strong>。</li><li>类成员标识符的作用域为整个类定义范围。</li></ul></li></ul><h4 id="2-例：一个日期类的定义"><a href="#2-例：一个日期类的定义" class="headerlink" title="2. 例：一个日期类的定义"></a>2. 例：一个日期类的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> <span class="hljs-comment">//成员函数</span></span><br><span class="hljs-function"></span>&#123; <br>year = y; <br>month = m; <br>day = d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_leap_year</span><span class="hljs-params">()</span> <span class="hljs-comment">//成员函数</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">return</span> (year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span> &amp;&amp; year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>) || (year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-comment">//成员函数</span></span><br><span class="hljs-function"></span>&#123; <br>cout &lt;&lt; year &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; month &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt;day;<br>&#125;<br>    ......<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> year,month,day; <span class="hljs-comment">//数据成员</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-数据成员"><a href="#3-数据成员" class="headerlink" title="3. 数据成员"></a>3. 数据成员</h4><ul><li><strong>数据成员</strong>是对类的对象所包含的数据描述，它们可以是常量和变量，类型可以是任意的C++类型（void除外）。</li><li>数据成员的描述格式与C的结构成员的描述格式相同，例如：   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> <span class="hljs-comment">//类定义</span><br>&#123;<br>......<br><span class="hljs-keyword">private</span>: <span class="hljs-comment">//访问控制说明</span><br><span class="hljs-type">int</span> year,month,day;  <span class="hljs-comment">//数据成员描述</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>在类中说明一个数据成员的类型时，如果未见到相应类型的定义，或相应的类型未定义完，则该数据成员的类型只能是这些类型的指针或引用类型。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<span class="hljs-comment">//A是在程序其它地方定义的类，这里是声明。  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a; <span class="hljs-comment">//Error，未见A的定义。</span><br>B b; <span class="hljs-comment">//Error，B还未定义完，递归了！</span><br>A *p;  <span class="hljs-comment">//OK</span><br>B *q;  <span class="hljs-comment">//OK</span><br>A &amp;aa; <span class="hljs-comment">//OK</span><br>B &amp;bb; <span class="hljs-comment">//OK</span><br>&#125;; <br></code></pre></td></tr></table></figure></li></ul><h4 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h4><ul><li><strong>成员函数</strong>是对类定义中的数据成员所能实施的操作描述。<br>成员函数的实现（函数体）可以放在类定义中，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;<br>...  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;...&#125; <span class="hljs-comment">//建议编译器按内联函数处理  </span><br>&#125;;   <br>成员函数的实现也可以放在类定义外，例如：  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;<br>...  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//声明  </span><br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::f</span><span class="hljs-params">()</span> </span>&#123; ... &#125; <span class="hljs-comment">//要用类名受限，区别于非成员函数（全局函数）  </span><br></code></pre></td></tr></table></figure></li><li>类成员函数名是可以重载的（析构函数除外），它遵循一般函数名的重载规则。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;<br>......  <br><span class="hljs-keyword">public</span>:  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></span>;  <br>......  <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-类成员的访问控制"><a href="#5-类成员的访问控制" class="headerlink" title="5. 类成员的访问控制"></a>5. 类成员的访问控制</h4><ul><li><p>在C++的类定义中，可以用访问控制修饰符public、private或protected来控制在类的外部对类成员的访问限制。例如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//访问不受限制。 </span><br><span class="hljs-type">int</span> x;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>: <span class="hljs-comment">//只能在本类和友元的代码中访问。 </span><br><span class="hljs-type">int</span> y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">protected</span>: <span class="hljs-comment">//只能在本类、派生类和友元的代码中访问。 </span><br><span class="hljs-type">int</span> z;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在C++的类定义中，可以有多个public、private和protected访问控制说明；默认访问控制是private。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> m,n; <span class="hljs-comment">//m,n的访问控制为private。</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">int y;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> z;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>一般来说，类的<strong>数据成员</strong>和在类的<strong>内部使用</strong>的<strong>成员函数</strong>应该指定为<strong>private</strong>，只有提供给<strong>外界使用</strong>的成员函数才指定为<strong>public</strong>。 </p><ul><li>具有public访问控制的成员构成了类与外界的一种<strong>接口</strong>（interface）。</li><li>在一个类的外部只能访问该类接口中的成员。</li></ul></li><li><p>protected类成员访问控制具有特殊的作用（在派生类中使用）。</p></li></ul><h3 id="（二）对象"><a href="#（二）对象" class="headerlink" title="（二）对象"></a>（二）对象</h3><h4 id="1-对象"><a href="#1-对象" class="headerlink" title="1. 对象"></a>1. 对象</h4><ul><li>类属于类型范畴的程序实体，它一般存在于静态的程序（编译程序看到的）中。</li><li>而动态（运行中）的面向对象程序则是由对象构成。</li><li>对象在程序运行时创建。</li></ul><h4 id="2-对象的创建和标识"><a href="#2-对象的创建和标识" class="headerlink" title="2. 对象的创建和标识"></a>2. 对象的创建和标识</h4><ul><li>直接方式<ul><li>通过在程序中定义一个类型为类的变量来实现的。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x,y;<br>&#125;<br>......<br>A a1;  <span class="hljs-comment">//创建一个A类的对象。</span><br>A a2[<span class="hljs-number">100</span>]; <span class="hljs-comment">//创建100个A类对象。</span><br></code></pre></td></tr></table></figure></li><li>对象在进入相应变量的生存期时创建，通过<strong>变量名</strong>来标识和访问。相应变量的生存期结束时，对象消亡。</li><li>分为：全局对象、局部对象和成员对象。</li></ul></li><li>间接方式（动态对象）<ul><li>在程序运行时刻，通过用<strong>new</strong>操作来创建对象，用<strong>delete</strong>操作来撤消（使之消亡）。对象通过<strong>指针</strong>来标识和访问。</li><li>单个动态对象的创建与撤消<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A *p;<br>p = <span class="hljs-keyword">new</span> A;  <span class="hljs-comment">// 创建一个A类的动态对象。</span><br>… *p … <span class="hljs-comment">//或，p-&gt;...，通过p访问动态对象</span><br><span class="hljs-keyword">delete</span> p;   <span class="hljs-comment">// 撤消p所指向的动态对象。</span><br></code></pre></td></tr></table></figure></li><li>动态对象数组的创建与撤消<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A *q;<br>q = <span class="hljs-keyword">new</span> A[<span class="hljs-number">100</span>];   <span class="hljs-comment">//创建一个动态对象数组。</span><br>...q[i]... <span class="hljs-comment">//或，*(q+i)，访问动态对象数组中的第i个对象</span><br><span class="hljs-keyword">delete</span> []q;   <span class="hljs-comment">//撤消q所指向的动态对象数组。 </span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-成员对象"><a href="#3-成员对象" class="headerlink" title="3. 成员对象"></a>3. 成员对象</h4><ul><li>对于类的数据成员，其类型可以是另一个类。即，一个对象可以包含另一个对象（称为成员对象）。例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>...<br>A a; <span class="hljs-comment">//成员对象</span><br>...<br>&#125;;<br>B b; <span class="hljs-comment">//对象b包含一个成员对象：b.a</span><br></code></pre></td></tr></table></figure></li><li>成员对象跟随包含它的对象一起创建和消亡。</li></ul><h4 id="4-对象的操作"><a href="#4-对象的操作" class="headerlink" title="4. 对象的操作"></a>4. 对象的操作</h4><ul><li><p>对于创建的一个对象，需要通过向它发送消息（调用对象类中定义的某个public成员函数）来对它进行操作。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a; <span class="hljs-comment">//创建A类的一个局部对象a。</span><br>a.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用A类的成员函数f对对象a进行操作。</span><br>A *p=<span class="hljs-keyword">new</span> A; <span class="hljs-comment">//创建A类的一个动态对象，p指向之。</span><br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用A类的成员函数f对p所指向的对象进行操作。</span><br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在类的外部，通过对象来访问类的成员时要受到类成员访问控制的限制，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>...... <span class="hljs-comment">//允许访问：x,y,f,g,h </span><br>A a;<br>...... <span class="hljs-comment">//允许访问：a.x、a.y、a.f、a.g和a.h</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>...... <span class="hljs-comment">//允许访问：x,y,f,g,h </span><br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>...... <span class="hljs-comment">//允许访问：x,y,f,g,h</span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <br>A a;<br>a.<span class="hljs-built_in">f</span>();    <span class="hljs-comment">//OK</span><br>a.x = <span class="hljs-number">1</span>;  <span class="hljs-comment">//Error</span><br>a.<span class="hljs-built_in">g</span>();    <span class="hljs-comment">//Error</span><br>a.y = <span class="hljs-number">1</span>;  <span class="hljs-comment">//Error</span><br>a.<span class="hljs-built_in">h</span>();    <span class="hljs-comment">//Error</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以对同类对象进行赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Date yesterday,today,some_day;<br>some_day = yesterday; <span class="hljs-comment">//默认是把对象yesterday的数据成员分别赋值给对象some_day的相应数据成员</span><br></code></pre></td></tr></table></figure></li><li><p>取对象地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Date today;<br>Date *p_date;<br>p_date = &amp;today; <span class="hljs-comment">//把对象today的地址赋值给指针p_date</span><br></code></pre></td></tr></table></figure></li><li><p>把对象作为参数传给函数。例如： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Date d)</span> <span class="hljs-comment">//创建一个新对象d，其数据成员用实参对象的数据成员对其初始化</span></span><br><span class="hljs-function"></span>&#123; ...... &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Date &amp;d)</span> <span class="hljs-comment">//不创建新对象，d就是实参对象！</span></span><br><span class="hljs-function"></span>&#123; ...... &#125;<br>Date today;<br><span class="hljs-built_in">f</span>(today); <span class="hljs-comment">//调用函数f，对象today不会被f修改</span><br><span class="hljs-built_in">g</span>(today); <span class="hljs-comment">//调用函数g，对象today会被g修改！</span><br></code></pre></td></tr></table></figure></li><li><p>把对象作为函数的返回值。例如，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Date <span class="hljs-title">f</span><span class="hljs-params">(Date &amp;d)</span></span><br><span class="hljs-function"></span>&#123;<br>d.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">//输出：2020.2.20</span><br><span class="hljs-keyword">return</span> d;  <span class="hljs-comment">//创建一个临时对象作为返回值，用d对其初始化</span><br>&#125;<br><span class="hljs-function">Date&amp; <span class="hljs-title">g</span><span class="hljs-params">(Date &amp;d)</span></span><br><span class="hljs-function"></span>&#123;<br>d.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">//输出：2020.2.20</span><br><span class="hljs-keyword">return</span> d;  <span class="hljs-comment">//不创建新对象，把对象d作为返回值</span><br>&#125;<br>Date some_day; <span class="hljs-comment">//创建一个日期对象</span><br>some_day.<span class="hljs-built_in">set</span>(<span class="hljs-number">2020</span>,<span class="hljs-number">2</span>,<span class="hljs-number">20</span>); <br><span class="hljs-built_in">f</span>(some_day).<span class="hljs-built_in">set</span>(<span class="hljs-number">2017</span>,<span class="hljs-number">3</span>,<span class="hljs-number">13</span>); some_day.<span class="hljs-built_in">print</span>(); <br><span class="hljs-built_in">g</span>(some_day).<span class="hljs-built_in">set</span>(<span class="hljs-number">2017</span>,<span class="hljs-number">3</span>,<span class="hljs-number">13</span>); some_day.<span class="hljs-built_in">print</span>(); <br><span class="hljs-comment">//前者显示：2020.2.20，因为修改的是临时对象</span><br><span class="hljs-comment">//后者显示：2017.3.13，因为修改的是some_day!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5-this指针"><a href="#5-this指针" class="headerlink" title="5. this指针"></a>5. this指针</h4><ul><li><p>类中的数据成员（静态数据成员除外）对该类的每个对象<strong>分别有一个拷贝</strong>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; x = i; &#125;;<br>...... <span class="hljs-comment">//其它成员函数</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x,y,z;<br>&#125;;<br>A a,b;  <br>a.<span class="hljs-built_in">g</span>(<span class="hljs-number">1</span>); b.<span class="hljs-built_in">g</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure> <div align=center><img src="/img/posts/AP-1-6.png" title="" height="50%" width="50%" /></div></li><li><p>类中的成员函数对该类的对象<strong>只有一个拷贝</strong></p></li><li><p>类的每一个成员函数（静态成员函数除外）都有一个<strong>隐藏</strong>的形参<strong>this</strong>，其类型为该类对象的指针；在成员函数中对类成员的访问是通过this来进行的。例如，</p><ul><li>对于前面A类的成员函数g：</li></ul><p>  <code>void g(int i) &#123; x = i; &#125;</code></p><ul><li>编译程序将会把它编译成：</li></ul><p>  <code>void g(A *const this, int i) &#123; this-&gt;x = i; &#125;;</code></p></li><li><p>当通过对象访问类的成员函数时，将会把相应对象的地址传给成员函数的this参数。例如，</p><ul><li>对于下面的成员函数调用：</li></ul><p>  <code>a.g(1);</code>和<code>b.g(2);</code></p><ul><li>编译程序将会把它编译成：</li></ul><p>  <code>g(&amp;a,1);</code>和<code>g(&amp;b,2);</code></p></li><li><p>一般情况下，类的成员函数中不必显式使用this指针，编译程序会自动加上。</p></li><li><p>但如果成员函数中要把this所指向的对象作为整体来操作，则需要显式地使用this指针。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A *p)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br> <span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; x = i;  <span class="hljs-built_in">func</span>(<span class="hljs-keyword">this</span>);    &#125; <br>    ...... <br>&#125;;<br>......<br>A a,b;<br>a.<span class="hljs-built_in">g</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//要求在g中调用func(&amp;a)</span><br>b.<span class="hljs-built_in">g</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//要求在g中调用func(&amp;b)</span><br></code></pre></td></tr></table></figure></li><li><p>用C语言实现C++的类</p><ul><li><p>对于一个C++程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>  <span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; x = i; <span class="hljs-built_in">f</span>(); &#125;<br>&#125;；<br>......<br>A a,b;<br>a.<span class="hljs-built_in">f</span>();<br>a.<span class="hljs-built_in">g</span>(<span class="hljs-number">1</span>);<br>b.<span class="hljs-built_in">f</span>();<br>b.<span class="hljs-built_in">g</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p>功能上与前面C++程序等价的C程序</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> x,y;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">f_A</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> A *this)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">g_A</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> A *this, <span class="hljs-type">int</span> i)</span><br>&#123;<br>this-&gt;x = i;<br>f_A(this);<br>&#125;<br>......<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-title">a</span>,<span class="hljs-title">b</span>;</span><br>f_A(&amp;a);<br>g_A(&amp;a,<span class="hljs-number">1</span>);<br>f_A(&amp;b);<br>g_A(&amp;b,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p>结论</p><ul><li>面向对象是一种程序设计思想，任何语言都可以实现</li><li>采用面向对象语言会使面向对象程序设计更加容易</li></ul></li></ul></li></ul><h2 id="四、对象的初始化和消亡前处理"><a href="#四、对象的初始化和消亡前处理" class="headerlink" title="四、对象的初始化和消亡前处理"></a>四、对象的初始化和消亡前处理</h2><h3 id="（一）构造函数"><a href="#（一）构造函数" class="headerlink" title="（一）构造函数"></a>（一）构造函数</h3><h4 id="1-对象的初始化——构造函数"><a href="#1-对象的初始化——构造函数" class="headerlink" title="1. 对象的初始化——构造函数"></a>1. 对象的初始化——构造函数</h4><ul><li><p>当一个对象创建时，它将获得一块存储空间，该存储空间用于存储对象的数据成员。在使用对象前，需要对对象存储空间中的数据成员进行初始化。</p></li><li><p>C++提供了一种对象初始化的机制：<strong>构造函数</strong></p><ul><li>它是类的特殊成员函数，名字与类名相同、无返回值类型。</li><li>创建对象时，构造函数会被自动调用。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">//构造函数</span><br>......<br>&#125;;<br>......<br>A a; <span class="hljs-comment">//创建对象a：为a分配内存空间，然后调用A类的构造函数A()。</span><br></code></pre></td></tr></table></figure> <div align=center><img src="/img/posts/AP-1-7.png" title="" height="25%" width="25%" /></div></li></ul></li><li><p>构造函数可以重载，其中，不带参数的（或所有参数都有默认值的）构造函数被称为<strong>默认构造函数</strong>。</p><ul><li>例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() <span class="hljs-comment">//默认构造函数</span><br>&#123;<br>x = y = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x1)<br>&#123;<br>x = x1;<br>y = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1)<br>&#123;<br>x = x1; <br>y = y1;<br>&#125;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>也可以写成功能等价的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x1=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> y1=<span class="hljs-number">0</span>)<br>&#123;<br>x = x1; <br>y = y1;<br>&#125;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在创建对象时，</p><ul><li>如果没有指定调用对象类中哪一个构造函数，则调用默认构造函数初始化。</li><li>也可以显式地指定调用对象类的某个构造函数。</li></ul></li></ul><h4 id="2-构造函数的调用"><a href="#2-构造函数的调用" class="headerlink" title="2. 构造函数的调用"></a>2. 构造函数的调用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>......<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>();<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i);<br><span class="hljs-built_in">A</span>(<span class="hljs-type">char</span> *p);<br>&#125;;<br>......<br>A a1;    <span class="hljs-comment">//调用默认构造函数。也可写成：A a1=A(); 但不能写成：A a1();</span><br><span class="hljs-function">A <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">//调用A(int i)。也可写成：A a2=A(1); 或 A a2=1; </span><br><span class="hljs-function">A <span class="hljs-title">a3</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;    <span class="hljs-comment">//调A(char *)。也可写成：A a3=A(&quot;abcd&quot;);或 A a3=&quot;abcd&quot;; </span><br>A a[<span class="hljs-number">4</span>];    <span class="hljs-comment">//调用对象a[0]、a[1]、a[2]、a[3]的默认构造函数。</span><br>A b[<span class="hljs-number">5</span>]=&#123;<span class="hljs-built_in">A</span>(),<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>),<span class="hljs-number">2</span>,<span class="hljs-string">&quot;xyz&quot;</span>&#125;;     <span class="hljs-comment">//调用b[0]的A()、b[1]的A(int)、b[2]的A(char *)、b[3]的A(int)和b[4]的A(char *)</span><br>A *p1=<span class="hljs-keyword">new</span> A;     <span class="hljs-comment">//调用默认构造函数</span><br>A *p2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);     <span class="hljs-comment">//调用A(int i)</span><br>A *p3=<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;xyz&quot;</span>);    <span class="hljs-comment">//调用A(char *)</span><br>A *p4=<span class="hljs-keyword">new</span> A[<span class="hljs-number">20</span>];   <span class="hljs-comment">//创建动态对象数组时只能调用各对象的默认构造函数</span><br></code></pre></td></tr></table></figure><ul><li>在程序中也可以通过类的构造函数来创建一些临时对象。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>......<br>a = <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//创建一个临时对象并把它赋值给a</span><br></code></pre></td></tr></table></figure></li><li><strong>注意</strong>：对象创建后，不能再调用构造函数。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>......<br>a.<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//Error!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-常量和引用数据成员的初始化"><a href="#3-常量和引用数据成员的初始化" class="headerlink" title="3. 常量和引用数据成员的初始化"></a>3. 常量和引用数据成员的初始化</h4><ul><li>对于常量和引用数据成员，不能在说明它们时初始化，也不能采用赋值操作在构造函数中对它们初始化。例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<span class="hljs-type">int</span> x;<br>     <span class="hljs-type">const</span> <span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;   <span class="hljs-comment">//Error</span><br>     <span class="hljs-type">int</span> &amp;z=x;     <span class="hljs-comment">//Error</span><br>   <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>()<br>     &#123; x = <span class="hljs-number">0</span>;    <span class="hljs-comment">//OK</span><br>     y = <span class="hljs-number">1</span>;    <span class="hljs-comment">//Error  </span><br>   z = &amp;x;  <span class="hljs-comment">//Error    </span><br>   z = x;  <span class="hljs-comment">//Error   </span><br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>可以在构造函数的函数头和函数体之间加入一个<strong>成员初始化表</strong>来对常量和引用数据成员进行初始化。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br> &#123;  <span class="hljs-type">int</span> x;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> y;<br>  <span class="hljs-type">int</span>&amp; z;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(): <span class="hljs-built_in">z</span>(x),<span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//成员初始化表</span><br>  &#123; x = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>在成员初始化表中，成员的书写次序并不决定它们的初始化次序，它们的初始化次序由它们在类定义中的描述次序来决定。</li></ul></li></ul><h3 id="（二）析构函数"><a href="#（二）析构函数" class="headerlink" title="（二）析构函数"></a>（二）析构函数</h3><ul><li><p>在类中可以定义一个特殊的成员函数：<strong>析构函数</strong>，它的名字为“~&lt;类名&gt;”，没有返回类型、不带参数、不能被重载。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;   ......<br>  <span class="hljs-keyword">public</span>:<br>     ......<br>     ~<span class="hljs-built_in">A</span>(); <span class="hljs-comment">//析构函数</span><br>&#125;; <br></code></pre></td></tr></table></figure></li><li><p>一个对象消亡时，系统在收回它的内存空间之前，将会<strong>自动调用</strong>对象类中的析构函数。可以在析构函数中完成对象被删除前的一些清理工作。</p></li><li><p>一般情况下，类中不需要自定义析构函数，但如果对象创建后，自己又<strong>额外</strong>申请了资源（如：额外申请了内存空间），则可以自定义析构函数来归还它们。</p></li><li><p>例如，在下面的程序中，系统为对象s1分配的内存空间只包含len和str（指针）本身所需的空间，str所指向的空间不由系统分配的，而是由对象作为资源自己申请的，s1消亡时，需要在析构函数中归还str指向的空间！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <br>&#123;<br><span class="hljs-type">int</span> len; <br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-type">char</span>* s)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(s);<br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len+<span class="hljs-number">1</span>]; <span class="hljs-comment">//申请额外的内存空间</span><br><span class="hljs-built_in">strcpy</span>(str, s);<br>&#125; <br>~<span class="hljs-built_in">String</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">//归还额外申请的空间</span><br>len = <span class="hljs-number">0</span>; <br>str = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//一般 情况下不需要这条语句。有时需要！</span><br>&#125;<br>......<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>; <span class="hljs-comment">//调用s1的构造函数</span><br>...... <br>&#125; <span class="hljs-comment">//调用s1的析构函数</span><br></code></pre></td></tr></table></figure></li><li><p>再例如：用链表实现的栈类，由于链表中的结点空间是push操作申请的，如果pop操作数量不够，则对象消亡时要归还它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Stack</span>() &#123; top = <span class="hljs-literal">NULL</span>; &#125;<br>~<span class="hljs-built_in">Stack</span>() <span class="hljs-comment">//析构函数</span><br>&#123;<br><span class="hljs-keyword">while</span> (top != <span class="hljs-literal">NULL</span>)<br>   &#123;<br>Node *p=top;<br>top = top-&gt;next;<br><span class="hljs-keyword">delete</span> p;<br>&#125;  <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> content;<br>Node *next;<br>&#125; *top;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>析构函数可以显式调用，这时并不是让对象消亡，而是暂时归还对象额外申请的资源。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>......<br>s1.~<span class="hljs-built_in">String</span>(); <span class="hljs-comment">//把字符串s1清空，对象并未消亡！</span><br>... s1 ... <span class="hljs-comment">//仍然可以使用对象s1</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="（三）成员对象的初始化和消亡处理"><a href="#（三）成员对象的初始化和消亡处理" class="headerlink" title="（三）成员对象的初始化和消亡处理"></a>（三）成员对象的初始化和消亡处理</h3><h4 id="1-成员对象的初始化和消亡处理的方法"><a href="#1-成员对象的初始化和消亡处理的方法" class="headerlink" title="1. 成员对象的初始化和消亡处理的方法"></a>1. 成员对象的初始化和消亡处理的方法</h4><ul><li>在创建包含成员对象的对象时，除了会自动调用本身类的构造函数外，还会自动去调用成员对象类的构造函数。<ul><li>通常是调用成员对象类的默认构造函数。</li><li>如果要调用成员对象类的<strong>非默认构造函数</strong>，需要在包含成员对象的对象类的构造函数<strong>成员初始化表</strong>中显式指出。</li></ul></li><li>包含成员对象的对象消亡时，除了会自动调用本身类的析构函数外，还会自动去调用成员对象类的析构函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; y = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i) &#123; y = i; &#125; <br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j): <span class="hljs-built_in">a</span>(j) &#123; y = i; &#125; <br>&#125;;<br>B b0; <span class="hljs-comment">//调用B()和A()：b0.y=0；b0.a.x=0</span><br><span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//调用B(int)和A()：b1.y=1；b1.a.x=0</span><br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//调用B(int,int)和A(int)：b2.y=1；b2.a.x=2</span><br>......<br><span class="hljs-comment">//b0、b1、b2消亡时，会分别去调用B和A的析构函数</span><br></code></pre></td></tr></table></figure><h4 id="2-成员对象初始化和消亡处理的次序"><a href="#2-成员对象初始化和消亡处理的次序" class="headerlink" title="2. 成员对象初始化和消亡处理的次序"></a>2. 成员对象初始化和消亡处理的次序</h4><ul><li>创建包含成员对象的对象时，<ul><li>先执行成员对象类的构造函数，再执行本对象类的构造函数。</li><li>若包含<strong>多个</strong>成员对象，这些成员对象的构造函数执行次序则按它们在<strong>本对象类中的说明次序</strong>进行。</li></ul></li><li>从实现上说，<ul><li>是先调用本身类的构造函数，但在<strong>进入函数体之前</strong>，会去调用成员对象类的构造函数，然后再执行本身类构造函数的函数体。</li><li>也就是说，构造函数的成员初始化表（即使没显式给出）中有对成员对象类的构造函数的调用代码。</li><li><strong>注意</strong>：如果类中未提供任何构造函数，但它包含成员对象，则编译程序会隐式地为之提供一个默认构造函数，其作用就是调用成员对象类的构造函数！</li></ul></li><li>对象消亡时，<ul><li>先执行本身类的析构函数，再执行成员对象类的析构函数。</li><li>如果有多个成员对象，则成员对象析构函数的执行次序则按它们在本对象类中的说明次序的<strong>逆序</strong>进行。</li><li>从实现上说，<ul><li>是先调用本身类的析构函数，<strong>本身类析构函数的函数体执行完之后</strong>，再去调用成员对象类的析构函数。</li><li>也就是说，析构函数的函数体最后有对成员对象类的析构函数的调用代码。</li><li><strong>注意</strong>：如果类中未提供析构函数，但它包含成员对象，则编译程序会隐式地为之提供一个析构函数，其作用就是调用成员对象类的析构函数。</li></ul></li></ul></li></ul><h3 id="（四）拷贝构造函数"><a href="#（四）拷贝构造函数" class="headerlink" title="（四）拷贝构造函数"></a>（四）拷贝构造函数</h3><h4 id="1-拷贝构造函数"><a href="#1-拷贝构造函数" class="headerlink" title="1. 拷贝构造函数"></a>1. 拷贝构造函数</h4><ul><li><p>若一个构造函数的参数类型为<strong>本类的引用</strong>，则称它为<strong>拷贝构造函数</strong>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>......<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>();  <span class="hljs-comment">//默认构造函数</span><br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a);  <span class="hljs-comment">//拷贝构造函数</span><br>&#125;; <br></code></pre></td></tr></table></figure></li><li><p>在创建一个对象时，若用另一个同类型的对象对其初始化，将会调用对象类中的拷贝构造函数。</p></li><li><p>在三种情况下，会调用类的拷贝构造函数：</p><ul><li>创建对象时显式指出。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a1; <br><span class="hljs-function">A <span class="hljs-title">a2</span><span class="hljs-params">(a1)</span></span>;  <span class="hljs-comment">//创建对象a2，用对象a1初始化对象a2</span><br></code></pre></td></tr></table></figure></li><li>把对象作为值参数传给函数时。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A x)</span> </span>&#123; ...... &#125;;<br>......<br>A a;<br><span class="hljs-built_in">f</span>(a);  <span class="hljs-comment">//创建形参对象x，用对象a对x进行初始化。</span><br></code></pre></td></tr></table></figure></li><li>把对象作为函数的返回值时。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">A <span class="hljs-title">f</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>A a;<br>......<br><span class="hljs-keyword">return</span> a; <span class="hljs-comment">//创建一个临时对象，用对象a对创建的临时对象进行初始化。</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-隐式拷贝构造函数"><a href="#2-隐式拷贝构造函数" class="headerlink" title="2. 隐式拷贝构造函数"></a>2. 隐式拷贝构造函数</h4><ul><li>在程序中，如果没有为某个类提供拷贝构造函数，则编译器将会为其生成一个<strong>隐式拷贝构造函数</strong>。</li><li>隐式拷贝构造函数将<strong>逐个成员</strong>进行拷贝初始化<ul><li>对于非对象成员：它采用通常的拷贝操作；</li><li>对于成员对象：则调用成员对象类的<strong>拷贝构造函数</strong>来对成员对象进行初始化。（<strong>递归定义</strong>）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = y = <span class="hljs-number">0</span>; &#125;<br>......<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-type">int</span> z;<br>A a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; z = <span class="hljs-number">0</span>; &#125;<br>...... <span class="hljs-comment">//其中没有定义拷贝构造函数</span><br>&#125;;<br>...<br>B b1; <span class="hljs-comment">//b1.z以及b1.a.x和b1.a.y均为0。</span><br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>; <span class="hljs-comment">//b2.z初始化成b1.z；</span><br>      <span class="hljs-comment">//调用A的拷贝构造函数用b1.a对b2.a初始化</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-自定义拷贝构造函数"><a href="#3-自定义拷贝构造函数" class="headerlink" title="3. 自定义拷贝构造函数"></a>3. 自定义拷贝构造函数</h4><ul><li><p>一般情况下，编译程序提供的隐式拷贝构造函数的行为足以满足要求，类中不需要自定义拷贝构造函数。</p></li><li><p>但在<strong>某些情况</strong>下，必须要自定义拷贝构造函数，否则，将会产生设计者未意识到的严重的程序错误。 </p></li><li><p>例如，在下面的类中没有自定义拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-type">char</span> *s) <br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(s); <br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len+<span class="hljs-number">1</span>]; <br><span class="hljs-built_in">strcpy</span>(str,s); <br>&#125;<br>~<span class="hljs-built_in">String</span>() &#123; <span class="hljs-keyword">delete</span> []str; len=<span class="hljs-number">0</span>; str=<span class="hljs-literal">NULL</span>; &#125;<br>&#125;;<br>......<br><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br><span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>系统提供的隐式拷贝构造函数将会使得s1和s2的成员指针str<strong>指向同一块内存区域</strong>！</p> <div align=center><img src="/img/posts/AP-1-8.png" title="" height="50%" width="50%" /></div></li><li><p>它带来的问题是：</p><ul><li>如果对一个对象（s1或s2）操作之后修改了这块空间的内容，则另一个对象将会受到影响。如果不是设计者特意所为，这将是一个隐藏的错误。</li><li>当对象s1和s2消亡时，将会分别去调用它们的析构函数，这会使得同一块内存区域将被归还两次，从而导致程序运行错误。</li><li>当对象s1和s2中有一个消亡，另一个还没消亡时，则会出现使用已被归还的空间问题。</li></ul></li><li><p>隐式拷贝构造函数实现的是一种<strong>浅拷贝</strong>（shallow copy），为了解决上面的问题，可以在类String中显式定义一个拷贝构造函数来实现<strong>深拷贝</strong>（deep copy）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; s)<br>&#123;len = s.len;<br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(str,s.str);<br>&#125;<br></code></pre></td></tr></table></figure> <div align=center><img src="/img/posts/AP-1-9.png" title="" height="100%" width="100%" /></div></li><li><p><strong>注意</strong>：自定义的拷贝构造函数默认调用的是成员对象类的<strong>默认构造函数</strong>来对成员对象初始化！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123; x++; y++; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-type">int</span> z;<br>A a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; z = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; b)   &#123; z = b.z; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123; z++; a.<span class="hljs-built_in">inc</span>(); &#125;<br>&#125;;<br>...<br>B b1;  /b1.z、b1.a.x和b1.a.y均为<span class="hljs-number">0</span><br>b1.<span class="hljs-built_in">inc</span>();  <span class="hljs-comment">//b1.z、b1.a.x和b1.a.y均变成了1</span><br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>; <span class="hljs-comment">//b2.z为1，b2.a.x和b2.a.y均为0</span><br></code></pre></td></tr></table></figure></li><li><p>若要保证b2与b1一致，则应在B类的拷贝构造函数的成员初始化表中显式指出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; b): <span class="hljs-built_in">a</span>(b.a)  &#123; z = b.z; &#125;<br></code></pre></td></tr></table></figure></li><li><p>下面对b2.a进行赋值初始化与拷贝构造的区别是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; ...... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-type">int</span> z;<br>A a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; ...... &#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; b)   <span class="hljs-comment">//这里还要调用A的默认构造函数对a初始化！</span><br>&#123;<br>z = b.z;<br>a = b.a;   <span class="hljs-comment">//这里是调用A的赋值操作给a赋值</span><br>&#125;<br>......<br>&#125;;<br>B b1;<br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="五、静态成员与友元"><a href="#五、静态成员与友元" class="headerlink" title="五、静态成员与友元"></a>五、静态成员与友元</h2><h3 id="（一）常成员函数及静态成员"><a href="#（一）常成员函数及静态成员" class="headerlink" title="（一）常成员函数及静态成员"></a>（一）常成员函数及静态成员</h3><h4 id="1-获取vs改变对象的状态"><a href="#1-获取vs改变对象的状态" class="headerlink" title="1. 获取vs改变对象的状态"></a>1. 获取vs改变对象的状态</h4><ul><li>在程序运行的不同时刻，一个对象可能会处于不同的状态（由对象的数据成员的值来体现）。</li><li>可以把类中的成员函数分成两类：<ul><li>获取对象状态（不改变数据成员的值）</li><li>改变对象状态（改变数据成员的值）</li></ul></li><li>例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>; <span class="hljs-comment">//改变对象状态</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取对象状态</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取对象状态</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_year</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取对象状态</span><br>......<br>&#125;; <br></code></pre></td></tr></table></figure></li></ul><h4 id="2-常成员函数"><a href="#2-常成员函数" class="headerlink" title="2. 常成员函数"></a>2. 常成员函数</h4><ul><li>为了防止在一个获取对象状态的成员函数中无意中修改对象的数据成员，可以把它说明成常成员函数。例如，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//常成员函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//常成员函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//常成员函数</span><br>......<br>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> year; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> day; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> month; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> </span>&#123; year=y; month=m; day=d; &#125;<br></code></pre></td></tr></table></figure></li><li>编译器一旦发现在常成员函数中修改数据成员的值，将会报错！</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记一</title>
    <link href="/2022/09/04/computer_network_note_1/"/>
    <url>/2022/09/04/computer_network_note_1/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章  绪论"></a>第一章  绪论</h1><h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1  什么是因特网"></a>1.1  什么是因特网</h2><h3 id="一、具体构成描述"><a href="#一、具体构成描述" class="headerlink" title="一、具体构成描述"></a>一、具体构成描述</h3><p>1．概念：因特网是一个世界范围的计算机网络，它是一个互联了遍及全世界的数以亿计的计算设备的网络，而且还有一批与因特网连接的新型设备。</p><p>2．所有连入因特网的设备都叫做主机或者端系统。</p><p>3．端系统通过通信链路和分组交换机连接到一起。</p><p>4．当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为分组。</p><p>5．分组交换机的种类：最为有名的是路由器和链路层交换机。两者的的不同之处在于，链路层交换机主要用在接入网中，路由器主要用在网络核心。</p><p>6．端系统通过因特网服务提供商（ISP）接入因特网。</p><p>7．端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接收和发送。因特网的主要协议统称为TCP&#x2F;IP。</p><h3 id="二、服务描述"><a href="#二、服务描述" class="headerlink" title="二、服务描述"></a>二、服务描述</h3><p>1．分布式的应用进程</p><p>2．用于通信基础设施（通过套接字API提供服务，面向连接与无连接的服务）</p><h3 id="三、协议"><a href="#三、协议" class="headerlink" title="三、协议"></a>三、协议</h3><p>1．协议：定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和／或接收一条报文或其他事件所采取的动作。</p><p>2．凡是通信实体的所有活动都要受到协议的约束。</p><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2  网络边缘"></a>1.2  网络边缘</h2><h3 id="一、端系统"><a href="#一、端系统" class="headerlink" title="一、端系统"></a>一、端系统</h3><p>1．端系统：与因特网相连的计算机和其它设备，往往处于网络的边缘。</p><p>2．端系统分类：客户和服务器。</p><h3 id="二、接入网"><a href="#二、接入网" class="headerlink" title="二、接入网"></a>二、接入网</h3><p>1．接入网：是指将端系统连入到边缘路由器的物理链路。</p><p>2．边缘路由器：是指端系统到任何其他远程端系统路径上的第一台路由器。</p><p>3．家庭接入：DSL、电缆、FTTH、拨号和卫星。</p><p>4．企业（和家庭）接入：以太网和WiFi。</p><p>5．广域无线接入：3G和LTE。</p><h3 id="三、物理媒体"><a href="#三、物理媒体" class="headerlink" title="三、物理媒体"></a>三、物理媒体</h3><p>双绞铜线、同轴电缆、光纤、陆地无线电信道、卫星无线电信道。</p><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3  网络核心"></a>1.3  网络核心</h2><h3 id="一、分组交换"><a href="#一、分组交换" class="headerlink" title="一、分组交换"></a>一、分组交换</h3><p>1．存储转发传输</p><p>（1）存储转发传输：在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p><p>（2）端到端时延</p><p>通过由N条速率均为R的链路组成的路径，从源到目的地发送一个分组，其端到端时延为：$d_{端到端}&#x3D;N\dfrac{L}{R}$ 。</p><p>2．排队时延和分组丢失</p><p>（1）因为需要缓存分组，所以分组交换机需要一个输出缓存和输出队列。</p><p>（2）缓冲队列的空间有限性可能导致分组交换机无法继续缓存分组而使到达分组交换机的数据包被迫丢弃，由此导致了分组不但承担了传输时延，还承担了排队时延。</p><p>3．转发表和路由选择协议</p><p>（1）分组交换机内部有一个转发表，维护了一个IP地址和链路的对应关系。</p><p>（2）处理流程为：</p><p>①通过分组的必要信息，获得目的端系统的IP地址。</p><p>②通过IP地址索引转发表，从而确定输出链路。</p><h3 id="二、电路交换"><a href="#二、电路交换" class="headerlink" title="二、电路交换"></a>二、电路交换</h3><p>1．电路交换网络中的复用</p><p>（1）时分复用（TDM）：将时间划分为固定区间的帧，每个帧则又被划分为固定数量的时间空隙。当网络需要建立一条连接时，网络将在每个帧中为该连接指定一个时隙。在该时隙内，链路用来传输该连接的数据。</p><p>（2）频分复用（FDM）：将频率域划分为频段，然后将频段分配给连接；此频段被用来专门传输链接的数据。该频段的宽度称为带宽。</p><p>2．分组交换与电路交换的对比</p><p>（1）分组交换的优点：</p><p>①它提供了比电路交换更好的带宽共享。</p><p>②它比电路交换更简单、更有效、实现成本更低。</p><p>（2）分组交换的缺点：分组交换不适合实时服务，因为端到端的时延是可变、不可预测的，这和整个网络的情况相关。</p><p>（3）电路交换的优点：提供了端对端传输数据的速率保证。</p><p>（4）电路交换的缺点：</p><p>①电路交换存在静默期，这是指专用电路空闲时，其占用的资源并没有得到充分的利用。</p><p>②建立连接的过程比较复杂。</p><p>（5）总体上来说，分组交换的性能要好于电路交换的性能。</p><table><thead><tr><th align="center"></th><th align="center">电路交换</th><th align="center">数据报分组交换</th><th align="center">虚电路分组交换</th></tr></thead><tbody><tr><td align="center">传输通路</td><td align="center">专用</td><td align="center">非专用</td><td align="center">非专用</td></tr><tr><td align="center">连续性</td><td align="center">连续传输</td><td align="center">分组传输</td><td align="center">分组传输</td></tr><tr><td align="center">带宽</td><td align="center">固定</td><td align="center">动态使用</td><td align="center">动态使用</td></tr><tr><td align="center">路由</td><td align="center">固定</td><td align="center">动态使用</td><td align="center">固定</td></tr><tr><td align="center">时延</td><td align="center">实时（只有呼叫建立时延）</td><td align="center">实时（只有呼叫建立时延）</td><td align="center">分组传输时延+呼叫建立时延</td></tr><tr><td align="center">扩展性</td><td align="center">差（接入用户有上限）</td><td align="center">好（用户数量可动态扩充）</td><td align="center">较好（用户数量动态，由拥塞控制来保证服务质量）</td></tr></tbody></table><h2 id="1-4-分组交换中的时延、丢包、吞吐量"><a href="#1-4-分组交换中的时延、丢包、吞吐量" class="headerlink" title="1.4  分组交换中的时延、丢包、吞吐量"></a>1.4  分组交换中的时延、丢包、吞吐量</h2><h3 id="一、分组交换网中的时延概述"><a href="#一、分组交换网中的时延概述" class="headerlink" title="一、分组交换网中的时延概述"></a>一、分组交换网中的时延概述</h3><p>1．时延：指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间。</p><p>2．时延的类型</p><p>（1）发送时延：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。</p><p>计算公式：发送时延＝分组长度／信道宽度</p><p>（2）传播时延：电磁波在信道中传播一定的距离需要花费的时间， 即一个比特从链路的一端传播到另一端所需的时间。</p><p>计算公式：传播时延＝信道长度／电磁波在信道上的传播速率</p><p>（3）处理时延：数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等。</p><p>（4）排队时延：分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p><p>（5）总时延＝发送时延＋传播时延＋处理时延＋排队时延<br>$$d_{nodal}&#x3D;d_{trans}+d_{prop}+d_{proc}+d_{queue}$$</p><p>3．传输时延和传播时延的对比</p><p>（1）传输时延是路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。</p><p>（2）传播时延是一个比特从一台路由器传播到另一台路由器所需的时间，是两台路由器之间距离的函数，而与分组长度或链路传输速率无关。</p><h3 id="二、排队时延和丢包"><a href="#二、排队时延和丢包" class="headerlink" title="二、排队时延和丢包"></a>二、排队时延和丢包</h3><p>1．丢包：到达的分组发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失。</p><p>2．影响因素</p><p>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关。如果分组到达的速度高于结点的处理速度，那么分组就会在缓冲队列里排队等待。当缓冲空间用完后，如果还有到的分组，那么该分组将被迫丢弃。</p><p>3．流量强度</p><p>（1）流量强度&#x3D;分组到达的速度／结点的处理速度。</p><p>（2）当流量强度持续大于1时，就将出现丢包现象。</p><h3 id="三、端到端时延"><a href="#三、端到端时延" class="headerlink" title="三、端到端时延"></a>三、端到端时延</h3><p>$$d_{end-end}&#x3D;N(d_{trans}+d_{prop}+d_{proc})$$ </p><h3 id="四、吞吐量"><a href="#四、吞吐量" class="headerlink" title="四、吞吐量"></a>四、吞吐量</h3><p>1．吞吐量：指单位时间内通过某个网络（或信道、接口）的数据量。</p><p>2．吞吐量可以近似为源和目的地之间路径的最小传输速率。</p><p>3．吞吐量受网络带宽或网络额定速率的限制。</p><h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5  协议层次及其服务模型"></a>1.5  协议层次及其服务模型</h2><h3 id="一、分层体系结构"><a href="#一、分层体系结构" class="headerlink" title="一、分层体系结构"></a>一、分层体系结构</h3><p>1．协议分层</p><p>因特网的协议栈有5个层次组成：</p><p>（1）应用层：应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为报文。</p><p>（2）传输层：传输层在应用程序端点之间传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为报文段。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。</p><p>（3）网络层：网络层将称为数据报的网络层分组从一台主机移动到另一台主机。网络层协议包含著名的IP协议以及其他一些路由选择协议。</p><p>（4）链路层：链路层将称为帧的链路层分组从一个节点移动到路径上的另一个端点。一个帧可能被沿途不同链路上的不同链路层协议处理。</p><p>（5）物理层：物理层的任务是将帧中的比特从一个结点移动到下一个节点，它提供了传输信息的实际物理通道。</p><p>2．OSI模型</p><p>OSI的模型一共有7层，从下到上依次为：物理层，链路层，网络层，传输层，会话层，表示层，应用层。相比因特网体系结构，OSI多了两层。</p><h3 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h3><p><img src="/img/posts/CN-1-1.jpg" alt="这是图片" title="分层与封装"></p><p>在发送主机端，一个应用层报文被传送给运输层。在最简单的情况下，运输层收取到报文并附上运输层首部信息，该首部将被接收端的运输层使用。</p><p>应用层报文和运输层首部信息一道构成了运输层报文段。运输层报文段因此封装了应用层报文。</p><p>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，从而生成了网络层数据报。</p><p>该数据报接下来被传递给链路层，链路层增加它自己的链路层首部信息并生成链路层帧。</p><p>在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段。有效载荷通常是来自上一层的分组。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/03/hello-world/"/>
    <url>/2022/09/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
